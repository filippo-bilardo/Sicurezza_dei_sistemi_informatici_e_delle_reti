# Crittografia PGP con Node.js e la libreria OpenPGP.js

La libreria **OpenPGP.js** porta lo standard OpenPGP (RFC 4880) direttamente nell'ecosistema JavaScript/Node.js, permettendo di cifrare, decifrare e firmare messaggi senza dipendere da strumenti esterni come GPG. In questa guida imparerai a integrare la crittografia PGP nelle tue applicazioni Node.js.

## Indice
1. [Introduzione teorica](#introduzione-teorica)
2. [Prerequisiti](#prerequisiti)
3. [Esercitazione Pratica 1](#esercitazione-pratica-1---setup-e-generazione-delle-chiavi)
4. [Esercitazione Pratica 2](#esercitazione-pratica-2---cifratura-e-decifratura)
5. [Esercitazione Pratica 3](#esercitazione-pratica-3---firma-digitale-e-verifica)
6. [Esercitazione Pratica 4](#esercitazione-pratica-4---api-express-con-messaggi-cifrati)
7. [Esercitazione Pratica 5](#esercitazione-pratica-5---interoperabilitÃ -con-gpg-cli)
8. [Verifica e Troubleshooting](#verifica-e-troubleshooting)
9. [Esercizi](#esercizi)


## Obiettivi della Lezione
- Comprendere come OpenPGP.js implementa lo standard OpenPGP in JavaScript
- Generare coppie di chiavi RSA ed ECC tramite codice Node.js
- Cifrare e decifrare messaggi usando l'API asincrona della libreria
- Firmare e verificare messaggi in un'applicazione Node.js
- Costruire un endpoint REST Express che accetta e restituisce messaggi cifrati
- Garantire l'interoperabilitÃ  tra OpenPGP.js e il tool a riga di comando GPG

## Introduzione teorica

### OpenPGP.js e il suo ruolo

**OpenPGP.js** Ã¨ l'implementazione JavaScript dello standard OpenPGP (RFC 4880), mantenuta da Proton (Proton Mail) e distribuita come pacchetto npm. Ãˆ la stessa libreria usata internamente da ProtonMail per la crittografia lato client.

```
Standard OpenPGP (RFC 4880 / 4880bis)
          â”‚
          â”œâ”€â”€ GnuPG (C)       â†’ tool CLI per desktop/server
          â”œâ”€â”€ OpenPGP.js      â†’ JavaScript / Node.js / Browser
          â”œâ”€â”€ Bouncy Castle   â†’ Java / Kotlin
          â””â”€â”€ GopenPGP        â†’ Go
```

La libreria Ã¨ importante perchÃ© consente di:
- Cifrare/decifrare **nel browser** senza trasmettere dati al server
- Integrare la crittografia nelle **REST API** Node.js
- Garantire **interoperabilitÃ ** con GPG desktop (stesso standard)

---

### Architettura di un'Applicazione con Messaggi Cifrati

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CLIENT (browser/app)                      â”‚
â”‚                                                              â”‚
â”‚  [Genera coppia chiavi] â†’ pubkey â†’ [Carica sul server]       â”‚
â”‚                                                              â”‚
â”‚  Messaggio in chiaro                                         â”‚
â”‚       â”‚                                                      â”‚
â”‚  [openpgp.encrypt(pubkey destinatario)]                      â”‚
â”‚       â”‚                                                      â”‚
â”‚  Messaggio cifrato  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º POST /api/messages        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                          â”‚
                                    [archiviato cifrato]
                                          â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    CLIENT (destinatario)                     â”‚
â”‚                                                              â”‚
â”‚               GET /api/messages/{id}                         â”‚
â”‚                    â”‚                                         â”‚
â”‚              Messaggio cifrato                               â”‚
â”‚                    â”‚                                         â”‚
â”‚  [openpgp.decrypt(chiave privata)]                           â”‚
â”‚                    â”‚                                         â”‚
â”‚              Messaggio in chiaro                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Vantaggi di questo approccio (E2E):**
- Il server vede solo dati cifrati â€” non puÃ² leggere i messaggi
- Anche in caso di data breach, i messaggi restano illeggibili
- La chiave privata non lascia mai il dispositivo dell'utente

---

### API asincrona di OpenPGP.js

OpenPGP.js usa esclusivamente API asincrone basate su **Promise** e **async/await**:

```javascript
// âœ… Corretto â€” async/await
const message  = await openpgp.createMessage({ text: 'ciao' });
const encrypted = await openpgp.encrypt({ message, encryptionKeys: pubKey });

// âŒ Errato â€” la libreria non ha API sincrone
const encrypted = openpgp.encrypt(...);  // restituisce Promise, non il risultato
```

**Tipi principali della libreria:**

| Tipo | Descrizione | Come si ottiene |
|------|-------------|-----------------|
| `PublicKey` | Chiave pubblica | `openpgp.readKey()` |
| `PrivateKey` | Chiave privata | `openpgp.decryptKey()` |
| `Message` | Messaggio da cifrare/firmare | `openpgp.createMessage()` |
| `CleartextMessage` | Messaggio in chiaro con firma | `openpgp.createCleartextMessage()` |
| `MaybeStream` | Output (stringa o stream) | ritorno di `encrypt()` / `decrypt()` |

---

## Prerequisiti

### Software Necessario

- **Node.js** v18 o superiore  
  Verifica: `node --version`
- **npm** v9 o superiore  
  Verifica: `npm --version`
- **GPG** (per l'esercitazione 5 â€” interoperabilitÃ )  
  Verifica: `gpg --version`

## Esercitazione Pratica 1 - Setup e Generazione delle Chiavi

### Step 1: Creare il Progetto Node.js

```bash
mkdir pgp-nodejs && cd pgp-nodejs
npm init -y
```

Installare la libreria OpenPGP.js:

```bash
npm install openpgp
```

Verifica l'installazione:
```bash
node -e "const openpgp = require('openpgp'); console.log('OpenPGP.js versione:', openpgp.config.versionString);"
```

Output atteso:
```
OpenPGP.js versione: OpenPGP.js v5.x.x
```

---

### Step 2: Generare una Coppia di Chiavi

Crea il file `01_genera_chiavi.js`:

```javascript
// 01_genera_chiavi.js
// Genera una coppia di chiavi ECC Curve25519 con OpenPGP.js

const openpgp = require('openpgp');
const fs = require('fs');

async function generaChiavi() {
  console.log('â³ Generazione chiavi in corso...\n');

  // Genera la coppia di chiavi
  const { privateKey, publicKey, revocationCertificate } = await openpgp.generateKey({
    type: 'ecc',              // 'ecc' (Curve25519) oppure 'rsa' con rsaBits: 4096
    curve: 'curve25519',      // curva ellittica
    userIDs: [{ name: 'Mario Rossi', email: 'mario.rossi@scuola.it' }],
    passphrase: 'SuperSegreto123!',  // protegge la chiave privata
    format: 'armored',        // output ASCII armored (-----BEGIN PGP...)
  });

  // Salva le chiavi su file
  fs.writeFileSync('chiave_pubblica.asc', publicKey);
  fs.writeFileSync('chiave_privata.asc', privateKey);
  fs.writeFileSync('certificato_revoca.asc', revocationCertificate);

  console.log('âœ… Chiavi generate e salvate:\n');
  console.log('ğŸ“„ chiave_pubblica.asc');
  console.log('ğŸ”’ chiave_privata.asc');
  console.log('âš ï¸  certificato_revoca.asc\n');
  console.log('--- Chiave Pubblica (prime righe) ---');
  console.log(publicKey.slice(0, 200) + '...\n');
}

generaChiavi().catch(console.error);
```

Esegui lo script:
```bash
node 01_genera_chiavi.js
```

Output atteso:
```
â³ Generazione chiavi in corso...

âœ… Chiavi generate e salvate:

ğŸ“„ chiave_pubblica.asc
ğŸ”’ chiave_privata.asc
âš ï¸  certificato_revoca.asc

--- Chiave Pubblica (prime righe) ---
-----BEGIN PGP PUBLIC KEY BLOCK-----

xsBNBAAA...
```

Verifica i file creati:
```bash
ls -la *.asc
cat chiave_pubblica.asc
```

---

### Step 3: Leggere e Ispezionare una Chiave

Crea il file `02_ispeziona_chiave.js`:

```javascript
// 02_ispeziona_chiave.js
// Legge ed ispeziona una chiave pubblica

const openpgp = require('openpgp');
const fs = require('fs');

async function ispezioneChiave() {
  // Legge la chiave pubblica dal file
  const armoredKey = fs.readFileSync('chiave_pubblica.asc', 'utf8');
  const chiave = await openpgp.readKey({ armoredKey });

  // Legge le informazioni
  const userID = chiave.getUserIDs()[0];
  const fingerprint = chiave.getFingerprint().toUpperCase();
  const keyID = chiave.getKeyID().toHex().toUpperCase();
  const creazione = chiave.getCreationTime();
  const scadenza = await chiave.getExpirationTime();
  const algoritmo = chiave.getAlgorithmInfo();

  console.log('=== Informazioni Chiave Pubblica ===\n');
  console.log(`ğŸ‘¤ Utente:      ${userID}`);
  console.log(`ğŸ”‘ Key ID:      ${keyID}`);
  console.log(`ğŸ–Šï¸  Fingerprint: ${fingerprint}`);
  console.log(`ğŸ“… Creata:      ${creazione.toLocaleDateString('it-IT')}`);
  console.log(`â³ Scadenza:    ${scadenza ? scadenza.toLocaleDateString('it-IT') : 'Nessuna'}`);
  console.log(`ğŸ§® Algoritmo:   ${algoritmo.algorithm} (${algoritmo.bits || algoritmo.curve || ''} bit)`);
}

ispezioneChiave().catch(console.error);
```

```bash
node 02_ispeziona_chiave.js
```

```
=== Informazioni Chiave Pubblica ===

ğŸ‘¤ Utente:      Mario Rossi <mario.rossi@scuola.it>
ğŸ”‘ Key ID:      A1B2C3D4E5F6A7B8
ğŸ–Šï¸  Fingerprint: A1B2C3D4E5F6A7B8C9D0E1F2A3B4C5D6E7F8A9B0
ğŸ“… Creata:      01/01/2026
â³ Scadenza:    Nessuna
ğŸ§® Algoritmo:   eddsa (curve25519)
```

---

## Esercitazione Pratica 2 - Cifratura e Decifratura

### Step 1: Cifrare un Messaggio

Crea il file `03_cifra.js`:

```javascript
// 03_cifra.js
// Cifra un messaggio con la chiave pubblica del destinatario

const openpgp = require('openpgp');
const fs = require('fs');

async function cifraMessaggio(testoInChiaro, recipientKeyFile) {
  console.log('ğŸ” Cifratura messaggio...\n');
  console.log('Testo originale:', testoInChiaro);

  // Carica la chiave pubblica del destinatario
  const armoredKey = fs.readFileSync(recipientKeyFile, 'utf8');
  const recipientKey = await openpgp.readKey({ armoredKey });

  // Crea l'oggetto messaggio
  const message = await openpgp.createMessage({ text: testoInChiaro });

  // Cifra il messaggio
  const encrypted = await openpgp.encrypt({
    message,
    encryptionKeys: recipientKey,   // chiave pubblica destinatario
  });

  // Salva su file
  fs.writeFileSync('messaggio_cifrato.asc', encrypted);

  console.log('\nâœ… Messaggio cifrato salvato in: messaggio_cifrato.asc');
  console.log('\n--- Contenuto cifrato (prime righe) ---');
  console.log(encrypted.slice(0, 180) + '...\n');

  return encrypted;
}

// Cifra un messaggio di esempio
const testo = 'Ciao Mario! Questo messaggio Ã¨ riservato. La password del server Ã¨: Tigre@2026';
cifraMessaggio(testo, 'chiave_pubblica.asc').catch(console.error);
```

```bash
node 03_cifra.js
```

```
ğŸ” Cifratura messaggio...

Testo originale: Ciao Mario! Questo messaggio Ã¨ riservato. La password del server Ã¨: Tigre@2026

âœ… Messaggio cifrato salvato in: messaggio_cifrato.asc

--- Contenuto cifrato (prime righe) ---
-----BEGIN PGP MESSAGE-----

wcBMA...
```

> âš ï¸ Il file `messaggio_cifrato.asc` contiene solo dati incomprensibili: senza la chiave privata di Mario Ã¨ impossibile leggerlo.

---

### Step 2: Decifrare un Messaggio

Crea il file `04_decifra.js`:

```javascript
// 04_decifra.js
// Decifra un messaggio con la propria chiave privata

const openpgp = require('openpgp');
const fs = require('fs');

async function decifraMessaggio(encryptedFile, privateKeyFile, passphrase) {
  console.log('ğŸ”“ Decifratura messaggio...\n');

  // Leggi il messaggio cifrato
  const armoredMessage = fs.readFileSync(encryptedFile, 'utf8');
  const message = await openpgp.readMessage({ armoredMessage });

  // Carica la chiave privata
  const armoredKey = fs.readFileSync(privateKeyFile, 'utf8');
  const encryptedPrivateKey = await openpgp.readPrivateKey({ armoredKey });

  // Decifra la chiave privata con la passphrase
  const privateKey = await openpgp.decryptKey({
    privateKey: encryptedPrivateKey,
    passphrase,
  });

  // Decifra il messaggio
  const { data: decrypted, signatures } = await openpgp.decrypt({
    message,
    decryptionKeys: privateKey,
  });

  console.log('âœ… Messaggio decifrato con successo!\n');
  console.log('--- Contenuto ---');
  console.log(decrypted);
  console.log('\n--- Info firma ---');
  if (signatures.length > 0) {
    console.log(`Firme presenti: ${signatures.length}`);
  } else {
    console.log('â„¹ï¸  Messaggio non firmato');
  }
}

// Decifra con la propria chiave privata
decifraMessaggio(
  'messaggio_cifrato.asc',
  'chiave_privata.asc',
  'SuperSegreto123!'           // passphrase impostata al momento della generazione
).catch(console.error);
```

```bash
node 04_decifra.js
```

```
ğŸ”“ Decifratura messaggio...

âœ… Messaggio decifrato con successo!

--- Contenuto ---
Ciao Mario! Questo messaggio Ã¨ riservato. La password del server Ã¨: Tigre@2026

--- Info firma ---
â„¹ï¸  Messaggio non firmato
```

---

### Step 3: Cifratura Simmetrica (solo passphrase)

```javascript
// 05_cifra_simmetrica.js
// Cifra con una passphrase condivisa (senza coppie di chiavi)

const openpgp = require('openpgp');
const fs = require('fs');

async function cifraSimmetrica(testo, passphrase) {
  const message = await openpgp.createMessage({ text: testo });

  const encrypted = await openpgp.encrypt({
    message,
    passwords: [passphrase],     // usa una passphrase invece delle chiavi asimmetriche
    config: { preferredSymmetricAlgorithm: openpgp.enums.symmetric.aes256 },
  });

  fs.writeFileSync('nota_cifrata_sym.asc', encrypted);
  console.log('âœ… File cifrato con passphrase: nota_cifrata_sym.asc');
}

async function decifraSimmetrica(file, passphrase) {
  const armoredMessage = fs.readFileSync(file, 'utf8');
  const message = await openpgp.readMessage({ armoredMessage });

  const { data } = await openpgp.decrypt({
    message,
    passwords: [passphrase],
  });

  console.log('âœ… Decifrato:', data);
}

(async () => {
  await cifraSimmetrica('Note riservate: appuntamento alle 15:00', 'passwordCondivisa42!');
  await decifraSimmetrica('nota_cifrata_sym.asc', 'passwordCondivisa42!');
})().catch(console.error);
```

---

## Esercitazione Pratica 3 - Firma Digitale e Verifica

### Step 1: Firmare un Messaggio (ClearText)

Crea il file `06_firma.js`:

```javascript
// 06_firma.js
// Firma un messaggio in chiaro: il testo rimane leggibile, la firma Ã¨ allegata

const openpgp = require('openpgp');
const fs = require('fs');

async function firmaMessaggio(testo, privateKeyFile, passphrase) {
  console.log('âœï¸  Firma messaggio...\n');

  // Carica e decifra la chiave privata
  const armoredKey = fs.readFileSync(privateKeyFile, 'utf8');
  const encryptedPrivateKey = await openpgp.readPrivateKey({ armoredKey });
  const privateKey = await openpgp.decryptKey({
    privateKey: encryptedPrivateKey,
    passphrase,
  });

  // Crea il messaggio cleartext (testo leggibile)
  const unsignedMessage = await openpgp.createCleartextMessage({ text: testo });

  // Firma il messaggio
  const signed = await openpgp.sign({
    message: unsignedMessage,
    signingKeys: privateKey,
  });

  // Salva
  fs.writeFileSync('comunicato_firmato.asc', signed);

  console.log('âœ… Messaggio firmato salvato in: comunicato_firmato.asc\n');
  console.log(signed);
}

firmaMessaggio(
  'Comunicato ufficiale: la verifica si terrÃ  il 10 marzo 2026.\nProf. Filippo Bilardo',
  'chiave_privata.asc',
  'SuperSegreto123!'
).catch(console.error);
```

```bash
node 06_firma.js
```

```
âœï¸  Firma messaggio...

âœ… Messaggio firmato salvato in: comunicato_firmato.asc

-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Comunicato ufficiale: la verifica si terrÃ  il 10 marzo 2026.
Prof. Filippo Bilardo
-----BEGIN PGP SIGNATURE-----

iQGzBAAB...
-----END PGP SIGNATURE-----
```

âœ… Il testo Ã¨ leggibile anche da chi non usa OpenPGP/GPG. La firma Ã¨ in fondo.

---

### Step 2: Verificare una Firma

Crea il file `07_verifica_firma.js`:

```javascript
// 07_verifica_firma.js
// Verifica l'autenticitÃ  e l'integritÃ  di un messaggio firmato

const openpgp = require('openpgp');
const fs = require('fs');

async function verificaFirma(signedFile, publicKeyFile) {
  console.log('ğŸ” Verifica firma in corso...\n');

  // Leggi il messaggio firmato
  const armoredMessage = fs.readFileSync(signedFile, 'utf8');
  const signedMessage = await openpgp.readCleartextMessage({ cleartextMessage: armoredMessage });

  // Carica la chiave pubblica del firmatario
  const armoredKey = fs.readFileSync(publicKeyFile, 'utf8');
  const verificationKey = await openpgp.readKey({ armoredKey });

  // Verifica la firma
  const verificationResult = await openpgp.verify({
    message: signedMessage,
    verificationKeys: verificationKey,
  });

  const { verified, keyID } = verificationResult.signatures[0];

  try {
    await verified; // Lancia eccezione se la firma non Ã¨ valida
    console.log('âœ… FIRMA VALIDA');
    console.log(`   Key ID del firmatario: ${keyID.toHex().toUpperCase()}`);
    console.log(`\n--- Testo del messaggio ---`);
    console.log(verificationResult.data);
  } catch (error) {
    console.log('âŒ FIRMA NON VALIDA:', error.message);
  }
}

verificaFirma('comunicato_firmato.asc', 'chiave_pubblica.asc').catch(console.error);
```

```bash
node 07_verifica_firma.js
```

```
ğŸ” Verifica firma in corso...

âœ… FIRMA VALIDA
   Key ID del firmatario: A1B2C3D4E5F6A7B8

--- Testo del messaggio ---
Comunicato ufficiale: la verifica si terrÃ  il 10 marzo 2026.
Prof. Filippo Bilardo
```

> âš ï¸ **Prova a modificare** il file `comunicato_firmato.asc` (cambia anche solo una lettera) e poi riesegui la verifica: GPG.js rileverÃ  la manomissione e riporterÃ  `âŒ FIRMA NON VALIDA`.

---

### Step 3: Cifrare e Firmare Insieme

```javascript
// 08_cifra_e_firma.js
// Cifra per il destinatario E firma con la propria chiave privata

const openpgp = require('openpgp');
const fs = require('fs');

async function cifraEFirma(testo, recipientKeyFile, senderPrivKeyFile, passphrase) {
  // Carica la chiave pubblica del destinatario
  const recipientKey = await openpgp.readKey({
    armoredKey: fs.readFileSync(recipientKeyFile, 'utf8'),
  });

  // Carica la chiave privata del mittente
  const encPrivKey = await openpgp.readPrivateKey({
    armoredKey: fs.readFileSync(senderPrivKeyFile, 'utf8'),
  });
  const senderKey = await openpgp.decryptKey({
    privateKey: encPrivKey,
    passphrase,
  });

  // Crea il messaggio
  const message = await openpgp.createMessage({ text: testo });

  // Cifra (chiave pubblica destinatario) + Firma (chiave privata mittente)
  const encrypted = await openpgp.encrypt({
    message,
    encryptionKeys: recipientKey,   // solo il destinatario puÃ² leggere
    signingKeys: senderKey,         // garantisce che il mittente Ã¨ autentico
  });

  fs.writeFileSync('msg_cifrato_firmato.asc', encrypted);
  console.log('âœ… Messaggio cifrato e firmato salvato in: msg_cifrato_firmato.asc');
  console.log('   Solo il destinatario puÃ² leggerlo, e sa che viene da te.');
}

cifraEFirma(
  'Messaggio riservato: le credenziali sono nell\'allegato.',
  'chiave_pubblica.asc',   // in un caso reale: chiave del destinatario
  'chiave_privata.asc',
  'SuperSegreto123!'
).catch(console.error);
```

---

## Esercitazione Pratica 4 - API Express con Messaggi Cifrati

In questa esercitazione costruiamo un mini-server HTTP con Express che espone endpoint REST per cifrare e decifrare messaggi, simulando un backend di messaggistica sicura E2E.

### Step 1: Installare le Dipendenze

```bash
npm install express
```

---

### Step 2: Struttura del Progetto

```
pgp-nodejs/
â”œâ”€â”€ 01_genera_chiavi.js
â”œâ”€â”€ 02_ispeziona_chiave.js
â”œâ”€â”€ ...
â”œâ”€â”€ server/
â”‚   â”œâ”€â”€ server.js          â† server Express
â”‚   â””â”€â”€ keystore.js        â† gestione chiavi in memoria
â”œâ”€â”€ chiave_pubblica.asc
â”œâ”€â”€ chiave_privata.asc
â””â”€â”€ package.json
```

```bash
mkdir server
```

---

### Step 3: Keystore in Memoria

Crea il file `server/keystore.js`:

```javascript
// server/keystore.js
// Simula un registro di chiavi pubbliche degli utenti (in produzione: database)

const openpgp = require('openpgp');

// Mappa email â†’ chiave pubblica armorata
const store = new Map();

async function registraUtente(email, armoredPublicKey) {
  // Valida la chiave prima di salvarla
  const key = await openpgp.readKey({ armoredKey: armoredPublicKey });
  store.set(email, { armoredPublicKey, fingerprint: key.getFingerprint() });
  console.log(`âœ… Registrato: ${email} (fp: ${key.getFingerprint().slice(0, 16)}...)`);
}

async function getChiave(email) {
  const entry = store.get(email);
  if (!entry) return null;
  return openpgp.readKey({ armoredKey: entry.armoredPublicKey });
}

function listaUtenti() {
  return [...store.entries()].map(([email, data]) => ({
    email,
    fingerprint: data.fingerprint,
  }));
}

module.exports = { registraUtente, getChiave, listaUtenti };
```

---

### Step 4: Server Express

Crea il file `server/server.js`:

```javascript
// server/server.js
// Mini-server REST con endpoint per cifratura/decifratura PGP

const express = require('express');
const openpgp = require('openpgp');
const fs = require('fs');
const path = require('path');
const keystore = require('./keystore');

const app = express();
app.use(express.json());

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// POST /api/keys  â€” registra una chiave pubblica
// Body: { "email": "...", "publicKey": "-----BEGIN PGP..." }
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.post('/api/keys', async (req, res) => {
  const { email, publicKey } = req.body;
  if (!email || !publicKey) {
    return res.status(400).json({ error: 'email e publicKey sono richiesti' });
  }
  try {
    await keystore.registraUtente(email, publicKey);
    res.json({ success: true, message: `Chiave registrata per ${email}` });
  } catch (err) {
    res.status(400).json({ error: 'Chiave non valida: ' + err.message });
  }
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// GET /api/keys  â€” lista delle chiavi registrate
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.get('/api/keys', (req, res) => {
  res.json({ utenti: keystore.listaUtenti() });
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// POST /api/encrypt  â€” cifra un messaggio per un utente registrato
// Body: { "recipient": "email@...", "message": "testo" }
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.post('/api/encrypt', async (req, res) => {
  const { recipient, message: testo } = req.body;
  if (!recipient || !testo) {
    return res.status(400).json({ error: 'recipient e message sono richiesti' });
  }

  const recipientKey = await keystore.getChiave(recipient);
  if (!recipientKey) {
    return res.status(404).json({ error: `Nessuna chiave trovata per ${recipient}` });
  }

  const message = await openpgp.createMessage({ text: testo });
  const encrypted = await openpgp.encrypt({
    message,
    encryptionKeys: recipientKey,
  });

  res.json({ encrypted });
});

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// POST /api/decrypt  â€” decifra un messaggio
// Body: { "encryptedMessage": "...", "passphrase": "..." }
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
app.post('/api/decrypt', async (req, res) => {
  const { encryptedMessage, passphrase } = req.body;
  if (!encryptedMessage || !passphrase) {
    return res.status(400).json({ error: 'encryptedMessage e passphrase sono richiesti' });
  }

  try {
    // Carica la chiave privata del server (in produzione non esporla mai!)
    const armoredKey = fs.readFileSync(
      path.join(__dirname, '..', 'chiave_privata.asc'), 'utf8'
    );
    const encPrivKey = await openpgp.readPrivateKey({ armoredKey });
    const privateKey = await openpgp.decryptKey({ privateKey: encPrivKey, passphrase });

    const message = await openpgp.readMessage({ armoredMessage: encryptedMessage });
    const { data } = await openpgp.decrypt({ message, decryptionKeys: privateKey });

    res.json({ decrypted: data });
  } catch (err) {
    res.status(400).json({ error: 'Decifratura fallita: ' + err.message });
  }
});

const PORT = 3000;
app.listen(PORT, () => {
  console.log(`\nğŸš€ Server in ascolto su http://localhost:${PORT}\n`);
  console.log('Endpoints disponibili:');
  console.log('  POST /api/keys    â€” registra chiave pubblica');
  console.log('  GET  /api/keys    â€” lista chiavi registrate');
  console.log('  POST /api/encrypt â€” cifra messaggio');
  console.log('  POST /api/decrypt â€” decifra messaggio');
});
```

---

### Step 5: Avviare il Server e Testare con curl

Avvia il server in un terminale:
```bash
node server/server.js
```

Output:
```
ğŸš€ Server in ascolto su http://localhost:3000

Endpoints disponibili:
  POST /api/keys    â€” registra chiave pubblica
  GET  /api/keys    â€” lista chiavi registrate
  POST /api/encrypt â€” cifra messaggio
  POST /api/decrypt â€” decifra messaggio
```

In un **secondo terminale**, testa gli endpoint:

#### 1. Registra la chiave pubblica
```bash
# Converti il file in una stringa JSON-safe
PUBKEY=$(cat chiave_pubblica.asc | jq -Rs .)

curl -s -X POST http://localhost:3000/api/keys \
  -H "Content-Type: application/json" \
  -d "{\"email\":\"mario.rossi@scuola.it\",\"publicKey\":$PUBKEY}" | jq
```

Output:
```json
{ "success": true, "message": "Chiave registrata per mario.rossi@scuola.it" }
```

#### 2. Cifra un messaggio
```bash
curl -s -X POST http://localhost:3000/api/encrypt \
  -H "Content-Type: application/json" \
  -d '{"recipient":"mario.rossi@scuola.it","message":"Codice segreto: 42"}' | jq
```

Output:
```json
{
  "encrypted": "-----BEGIN PGP MESSAGE-----\n\nwcBMA...\n-----END PGP MESSAGE-----\n"
}
```

#### 3. Decifra il messaggio
```bash
# Salva il messaggio cifrato e decifra
curl -s -X POST http://localhost:3000/api/decrypt \
  -H "Content-Type: application/json" \
  -d '{
    "encryptedMessage": "-----BEGIN PGP MESSAGE-----\n\nwcBMA...\n-----END PGP MESSAGE-----\n",
    "passphrase": "SuperSegreto123!"
  }' | jq
```

Output:
```json
{ "decrypted": "Codice segreto: 42" }
```

---

## Esercitazione Pratica 5 - InteroperabilitÃ  con GPG CLI

Uno dei punti di forza di OpenPGP.js Ã¨ la piena compatibilitÃ  con GPG da riga di comando. Un messaggio cifrato da Node.js puÃ² essere decifrato con GPG e viceversa.

### Step 1: Importare la Chiave Node.js in GPG

```bash
# La chiave generata da OpenPGP.js Ã¨ standard OpenPGP â†’ si importa normalmente in GPG
gpg --import chiave_pubblica.asc
gpg --import chiave_privata.asc     # GPG chiederÃ  la passphrase: SuperSegreto123!

# Verifica l'importazione
gpg --list-keys mario.rossi@scuola.it
```

---

### Step 2: Decifra con GPG un Messaggio Cifrato da Node.js

```bash
# Il server Node.js ha cifrato il file messaggio_cifrato.asc
# Decifriamo con il tool GPG da riga di comando
gpg --decrypt messaggio_cifrato.asc
```

Output:
```
gpg: cifrato con chiave cv25519 [ID], creata 2026-01-01
      "Mario Rossi <mario.rossi@scuola.it>"
Ciao Mario! Questo messaggio Ã¨ riservato. La password del server Ã¨: Tigre@2026
```

âœ… GPG riesce a decifrare un messaggio cifrato da OpenPGP.js â€” stessa chiave, stesso standard.

---

### Step 3: Cifra con GPG e Decifra con Node.js

```bash
# Crea e cifra un messaggio con GPG
echo "Risposta da GPG: confermato ricevuto." | \
  gpg --armor --encrypt --recipient mario.rossi@scuola.it > risposta_gpg.asc

cat risposta_gpg.asc
```

Crea il file `09_decifra_da_gpg.js`:

```javascript
// 09_decifra_da_gpg.js
// Decifra con Node.js un messaggio cifrato dalla CLI di GPG

const openpgp = require('openpgp');
const fs = require('fs');

async function main() {
  const armoredMessage = fs.readFileSync('risposta_gpg.asc', 'utf8');
  const message = await openpgp.readMessage({ armoredMessage });

  const encPrivKey = await openpgp.readPrivateKey({
    armoredKey: fs.readFileSync('chiave_privata.asc', 'utf8'),
  });
  const privateKey = await openpgp.decryptKey({
    privateKey: encPrivKey,
    passphrase: 'SuperSegreto123!',
  });

  const { data } = await openpgp.decrypt({
    message,
    decryptionKeys: privateKey,
  });

  console.log('âœ… Decifrato da Node.js:', data);
}

main().catch(console.error);
```

```bash
node 09_decifra_da_gpg.js
```

```
âœ… Decifrato da Node.js: Risposta da GPG: confermato ricevuto.
```

âœ… **InteroperabilitÃ  confermata**: GPG CLI â†” OpenPGP.js funzionano senza problemi.

---

## Verifica e Troubleshooting

### Verificare la Versione di OpenPGP.js

```bash
node -e "const o = require('openpgp'); console.log(o.config.versionString);"
cat node_modules/openpgp/package.json | grep '"version"' | head -1
```

### Problemi Comuni

#### 1. `Error: Misformed armored text`

**Causa**: la stringa armored (`-----BEGIN PGP...`) Ã¨ stata troncata, ha caratteri extra o newline errati (es. conversione JSON mal gestita).

**Soluzione:**
```javascript
// Assicurarsi che la stringa sia intatta quando si passa da JSON
const armoredKey = fs.readFileSync('chiave_pubblica.asc', 'utf8');
// NON usare JSON.stringify/parse senza gestire correttamente i newline
const keyInJson = JSON.stringify(armoredKey);    // âœ… conserva \n come \\n
```

#### 2. `Error: Incorrect key passphrase`

**Causa**: la passphrase non corrisponde a quella usata al momento della generazione.

**Soluzione:** Non Ã¨ possibile recuperare la passphrase. Controlla di non aver spazi o caratteri extra:
```javascript
// âœ… Usa .trim() per rimuovere spazi/newline accidentali
const passphrase = process.env.GPG_PASSPHRASE?.trim() || 'SuperSegreto123!';
```

#### 3. `Error: Could not find valid encryption key packet`

**Causa**: si sta tentando di decifrare con la chiave sbagliata (il messaggio non era cifrato per quella chiave).

**Soluzione:**
```javascript
// Verifica il Key ID del destinatario nel messaggio
const msg = await openpgp.readMessage({ armoredMessage });
const packets = msg.packets;
// Controlla quali Key ID sono nel messaggio
```

#### 4. `Error: Uncompressed point must start with 0x04`

**Causa**: versione incompatibile di OpenPGP.js (es. v4 vs v5). La v5 usa un formato ECC diverso.

**Soluzione:**
```bash
# Aggiorna alla versione piÃ¹ recente
npm install openpgp@latest
# Oppure specifica la versione compatibile
npm install openpgp@5
```

#### 5. `ReferenceError: require is not defined`

**Causa**: il progetto usa ES Modules (`"type": "module"` in `package.json`) ma il codice usa `require`.

**Soluzione â€” Opzione A**: rimuovi `"type": "module"` da `package.json`.

**Soluzione â€” Opzione B**: usa la sintassi ES Module:
```javascript
// Con ES Modules (usare .mjs o "type":"module")
import * as openpgp from 'openpgp';
```

---

## Esercizi

### Esercizio 1: Generazione e Ispezione (â˜…â˜†â˜†)

1. Genera due coppie di chiavi distinte con diversi parametri:  
   a) ECC Curve25519 senza passphrase  
   b) RSA 4096 con passphrase e scadenza di 6 mesi
2. Usa `02_ispeziona_chiave.js` (modificato) per stampare le informazioni di entrambe le chiavi
3. Confronta dimensione dei file `.asc` generati: quale Ã¨ piÃ¹ grande?

**Domande:**
- Come si specifica `rsaBits: 4096` in `generateKey()`?
- PerchÃ© ECC produce chiavi piÃ¹ piccole di RSA pur garantendo sicurezza equivalente?

### Esercizio 2: Cifratura Multi-Destinatario (â˜…â˜…â˜†)

1. Genera una seconda coppia di chiavi (simula un secondo utente)
2. Modifica `03_cifra.js` per cifrare lo stesso messaggio per **due destinatari** (passa un array a `encryptionKeys`)
3. Decifra il messaggio con entrambe le chiavi private e verifica che il testo sia identico
4. Salva le due decifrature su file separati e confrontale con `diff`

**Domande:**
- Come il formato PGP permette la decifratura a piÃ¹ destinatari mantenendo un solo ciphertext?
- Cosa succede se si tenta di decifrare con una terza chiave non inclusa?

### Esercizio 3: Middleware Express di Decifratura (â˜…â˜…â˜†)

1. Aggiungi al server Express un middleware che legge l'header `X-Encrypted-Payload`
2. Se l'header Ã¨ presente, decifra automaticamente il corpo della richiesta prima di passarla al controller
3. Aggiungi un endpoint `POST /api/secure-echo` che risponde con il testo decifrato
4. Testa con `curl` passando un messaggio cifrato nell'header

**Domande:**
- Quali sono i rischi di esporre l'endpoint di decifratura su una API pubblica?
- In un'architettura E2E reale, dove andrebbe eseguita la decifratura?

### Esercizio 4: Firma e Verifica di un JSON (â˜…â˜…â˜…)

1. Crea un oggetto JavaScript che rappresenta un "token di accesso" (es. `{ userId: 42, role: 'admin', exp: ... }`)
2. Serializzalo con `JSON.stringify` e firmalo con `--clearsign`
3. Crea una funzione `verificaToken(signedToken, publicKeyFile)` che verifica la firma e ritorna l'oggetto parsato
4. Simula una manomissione del token e verifica che la funzione lanci un'eccezione

**Domande:**
- Rispetto a JWT (JSON Web Token), quali vantaggi offre la firma PGP?
- Quali svantaggi ha PGP per questo caso d'uso?

### Esercizio 5: CLI Tool per Cifratura File (â˜…â˜…â˜…)

Crea uno script Node.js `pgp-cli.js` che accetta argomenti da riga di comando:

```bash
node pgp-cli.js encrypt --file report.pdf --recipient mario@scuola.it --keyfile mario_pub.asc
node pgp-cli.js decrypt --file report.pdf.asc --keyfile privata.asc --passphrase "abc"
node pgp-cli.js sign    --file documento.txt --keyfile privata.asc --passphrase "abc"
node pgp-cli.js verify  --file documento.txt.asc --keyfile pubblica.asc
```

Utilizza il modulo `process.argv` o la libreria `minimist` (`npm install minimist`).

**Domande:**
- Come gestiresti in modo sicuro la passphrase senza passarla come argomento CLI (visibile in `ps aux`)?
- Come useresti le variabili d'ambiente per migliorare la sicurezza?

---

## Riferimenti e Approfondimenti

### Documentazione Ufficiale
- [OpenPGP.js â€“ Documentazione](https://openpgpjs.org/)
- [OpenPGP.js â€“ GitHub](https://github.com/openpgpjs/openpgpjs)
- [OpenPGP Standard â€“ RFC 4880](https://datatracker.ietf.org/doc/html/rfc4880)
- [ProtonMail â€“ Come usa OpenPGP.js](https://proton.me/blog/protonmail-open-source)

### Pacchetti npm Correlati
- [`openpgp`](https://www.npmjs.com/package/openpgp) â€“ libreria principale usata in questa guida
- [`node-forge`](https://www.npmjs.com/package/node-forge) â€“ crittografia generale in Node.js
- [`jose`](https://www.npmjs.com/package/jose) â€“ JSON Web Tokens (JWE, JWS)

### Comandi di Riferimento Rapido

```javascript
const openpgp = require('openpgp');

// â”€â”€â”€â”€â”€ GENERAZIONE CHIAVI â”€â”€â”€â”€â”€
const { privateKey, publicKey } = await openpgp.generateKey({
  type: 'ecc', curve: 'curve25519',
  userIDs: [{ name: 'Nome', email: 'email@dominio.it' }],
  passphrase: 'abc', format: 'armored',
});

// â”€â”€â”€â”€â”€ LEGGERE CHIAVI â”€â”€â”€â”€â”€
const pubKey  = await openpgp.readKey({ armoredKey: fs.readFileSync('pub.asc','utf8') });
const encPriv = await openpgp.readPrivateKey({ armoredKey: fs.readFileSync('priv.asc','utf8') });
const privKey = await openpgp.decryptKey({ privateKey: encPriv, passphrase: 'abc' });

// â”€â”€â”€â”€â”€ CIFRATURA â”€â”€â”€â”€â”€
const msg = await openpgp.createMessage({ text: 'ciao' });
const enc = await openpgp.encrypt({ message: msg, encryptionKeys: pubKey });

// â”€â”€â”€â”€â”€ DECIFRATURA â”€â”€â”€â”€â”€
const cipherMsg = await openpgp.readMessage({ armoredMessage: enc });
const { data } = await openpgp.decrypt({ message: cipherMsg, decryptionKeys: privKey });

// â”€â”€â”€â”€â”€ FIRMA â”€â”€â”€â”€â”€
const clearMsg = await openpgp.createCleartextMessage({ text: 'testo' });
const signed   = await openpgp.sign({ message: clearMsg, signingKeys: privKey });

// â”€â”€â”€â”€â”€ VERIFICA FIRMA â”€â”€â”€â”€â”€
const signedMsg = await openpgp.readCleartextMessage({ cleartextMessage: signed });
const result    = await openpgp.verify({ message: signedMsg, verificationKeys: pubKey });
await result.signatures[0].verified;   // lancia eccezione se non valida

// â”€â”€â”€â”€â”€ CIFRA + FIRMA â”€â”€â”€â”€â”€
const enc2 = await openpgp.encrypt({
  message: await openpgp.createMessage({ text: 'ciao' }),
  encryptionKeys: pubKey,
  signingKeys: privKey,
});
```

---

## Conclusioni

Hai imparato a:
âœ… Installare e configurare OpenPGP.js in un progetto Node.js  
âœ… Generare coppie di chiavi RSA ed ECC tramite codice  
âœ… Cifrare e decifrare messaggi con API async/await  
âœ… Firmare messaggi e verificarne l'autenticitÃ   
âœ… Costruire un server Express con endpoint REST per messaggistica cifrata  
âœ… Garantire l'interoperabilitÃ  tra OpenPGP.js e GPG da riga di comando  

OpenPGP.js porta la crittografia PGP direttamente nelle applicazioni web e Node.js, permettendo di costruire sistemi di messaggistica **end-to-end encrypted** dove nemmeno il server puÃ² leggere i dati degli utenti. Questa Ã¨ la base su cui sono costruiti servizi come ProtonMail e Signal.

---

**Autore**: Prof. Filippo Bilardo  
**Corso**: Sistemi e Reti 3  
**Data**: Febbraio 2026
