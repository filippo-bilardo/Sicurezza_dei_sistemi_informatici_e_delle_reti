# Backup Crittografati End-to-End con Node.js e PGP

I servizi cloud come AWS S3 e Google Cloud Storage sono infrastrutture sicure, ma il provider detiene le chiavi di cifratura: tecnicamente potrebbe accedere ai tuoi dati. Con la crittografia **end-to-end (E2E)** applicata prima dell'upload, solo il proprietario della chiave privata puÃ² leggere i dati â€” accesso fisico al bucket non Ã¨ sufficiente. In questa esercitazione costruirai un agente di backup Node.js che cifra ogni file con OpenPGP.js prima di caricarlo su cloud, e lo decifra localmente al momento del ripristino.

## Indice
1. [Introduzione teorica](#introduzione-teorica)
2. [Prerequisiti](#prerequisiti)
3. [Esercitazione Pratica 1](#esercitazione-pratica-1---setup-e-struttura-del-progetto)
4. [Esercitazione Pratica 2](#esercitazione-pratica-2---motore-di-cifratura-e-decifratura)
5. [Esercitazione Pratica 3](#esercitazione-pratica-3---backend-di-storage-locale-e-s3)
6. [Esercitazione Pratica 4](#esercitazione-pratica-4---agente-di-backup-completo)
7. [Esercitazione Pratica 5](#esercitazione-pratica-5---ripristino-e-verifica-integrit%C3%A0)
8. [Esercitazione Pratica 6 (OPZIONALE)](#esercitazione-pratica-6-opzionale---backup-automatico-con-scheduling)
9. [Verifica e Troubleshooting](#verifica-e-troubleshooting)
10. [Esercizi](#esercizi)


## Obiettivi della Lezione
- Comprendere il modello di sicurezza E2E applicato ai backup cloud
- Implementare la cifratura ibrida (session key AES + RSA/ECC) per file di grandi dimensioni
- Costruire un agente di backup Node.js con supporto a storage locale e AWS S3
- Gestire manifest di backup cifrati per garantire integritÃ  e tracciabilitÃ 
- Implementare il ripristino selettivo con verifica dell'integritÃ  tramite hash SHA-256
- Analizzare le limitazioni e best practice di sicurezza per sistemi di backup E2E

## Introduzione teorica

### Il Problema: Cloud Storage senza E2E

Quando carichi un file su AWS S3 o Google Cloud Storage con la cifratura "lato server" (SSE), il provider gestisce le chiavi:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               CIFRATURA LATO SERVER (SSE) â€” âš ï¸ INSICURA E2E  â”‚
â”‚                                                               â”‚
â”‚  Il tuo file â”€â”€â–º HTTPS â”€â”€â–º [Provider riceve file in chiaro]   â”‚
â”‚                                    â”‚                          â”‚
â”‚                              [Provider cifra]                 â”‚
â”‚                              con proprie chiavi               â”‚
â”‚                                    â”‚                          â”‚
â”‚                              [File cifrato]                   â”‚
â”‚                              nel bucket                       â”‚
â”‚                                                               â”‚
â”‚  Chi puÃ² leggere: tu + provider + chi ottiene accesso al      â”‚
â”‚  pannello di controllo del provider                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

Con **cifratura E2E lato client**, il file arriva al provider giÃ  cifrato:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            CIFRATURA E2E LATO CLIENT â€” âœ… SICURA              â”‚
â”‚                                                               â”‚
â”‚  Il tuo file â”€â”€â–º [OpenPGP.js cifra localmente]                â”‚
â”‚                          â”‚                                    â”‚
â”‚                   File cifrato .pgp                           â”‚
â”‚                          â”‚                                    â”‚
â”‚                    HTTPS upload                               â”‚
â”‚                          â”‚                                    â”‚
â”‚                  [Provider riceve]                            â”‚
â”‚                  solo dati cifrati                            â”‚
â”‚                  (non puÃ² leggere)                            â”‚
â”‚                                                               â”‚
â”‚  Chi puÃ² leggere: SOLO chi possiede la chiave privata         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### Architettura dell'Agente di Backup

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        AGENTE DI BACKUP                             â”‚
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Scanner     â”‚    â”‚  Crypto Engineâ”‚    â”‚  Storage Backend    â”‚   â”‚
â”‚  â”‚  (fs.readdir)â”‚â”€â”€â”€â–ºâ”‚  (OpenPGP.js) â”‚â”€â”€â”€â–ºâ”‚  Local / S3 / GCS   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚         â”‚                    â”‚                       â”‚              â”‚
â”‚         â”‚              session key                   â”‚              â”‚
â”‚         â”‚            AES-256 per file                â”‚              â”‚
â”‚         â”‚                    â”‚                       â”‚              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                      MANIFEST (cifrato)                       â”‚  â”‚
â”‚  â”‚  { file, hash_sha256, timestamp, storage_path, key_id }       â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Componenti principali:**

| Componente | Ruolo |
|------------|-------|
| Scanner | Trovare i file da includere nel backup |
| Crypto Engine | Cifrare ogni file con session key AES-256 + chiave pubblica |
| Storage Backend | Astrazione per upload/download (locale, S3, GCS) |
| Manifest | Registro cifrato dei file backuppati con hash e metadati |

---

### Strategia di Cifratura per File di Grandi Dimensioni

PGP usa giÃ  internamente la **crittografia ibrida**:

```
Per ogni file da backuppare:

  1. Genera session key casuale (AES-256, 256 bit)
  2. Cifra il file con la session key  â”€â”€â–º file.pgp (contenuto)
  3. Cifra la session key con RSA/ECC  â”€â”€â–º session key cifrata
  4. Salva entrambi nel file .pgp finale

Solo il proprietario della chiave privata puÃ²:
  - Decifrare la session key
  - Usarla per decifrare il file

OpenPGP.js esegue questi passi automaticamente in encrypt().
```

**Vantaggi per i backup:**
- Ogni file ha una session key diversa e casuale
- Se una session key venisse compromessa, gli altri file restano sicuri
- La chiave privata non deve mai essere trasmessa o caricata sul cloud

---

### Struttura di un Backup E2E

```
bucket-backup/
â”œâ”€â”€ manifests/
â”‚   â””â”€â”€ backup_20260226_143000.json.pgp   â† manifest cifrato
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ a3f8c1d2e4b5.pgp                  â† file cifrato (nome randomizzato)
â”‚   â”œâ”€â”€ 7b2e9f4a1c3d.pgp
â”‚   â””â”€â”€ ...
â””â”€â”€ keys/
    â””â”€â”€ pubkey_backup.asc                 â† chiave pubblica (non segreta)
```

> âš ï¸ I nomi dei file sono randomizzati per non rivelare la struttura delle directory anche a chi accede fisicamente al bucket.

---

## Prerequisiti

### Software Necessario

- **Node.js** v18 o superiore (`node --version`)
- **npm** v9 o superiore (`npm --version`)
- **GPG** installato (opzionale, per verifica interoperabilitÃ )
- Account **AWS** con bucket S3 (solo per Esercitazione 3 â€“ parte S3)

> âš ï¸ Le esercitazioni 1, 2, 4 e 5 usano uno storage backend locale e **non richiedono** account cloud. AWS S3 Ã¨ introdotto come opzione nella Pratica 3.

### Creare il Progetto

```bash
mkdir backup-e2e && cd backup-e2e
npm init -y
npm install openpgp @aws-sdk/client-s3 dotenv crypto-js minimist
```

**Dipendenze:**

| Pacchetto | Utilizzo |
|-----------|----------|
| `openpgp` | Cifratura/decifratura PGP |
| `@aws-sdk/client-s3` | Upload/download su AWS S3 |
| `dotenv` | Carica variabili d'ambiente da `.env` |
| `minimist` | Parsing argomenti CLI |

Struttura iniziale del progetto:

```bash
mkdir -p src keys backups/local test-data
```

```
backup-e2e/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ crypto.js        â† motore crittografico
â”‚   â”œâ”€â”€ storage.js       â† backend storage (locale + S3)
â”‚   â”œâ”€â”€ manifest.js      â† gestione manifest cifrato
â”‚   â”œâ”€â”€ backup.js        â† agente di backup
â”‚   â””â”€â”€ restore.js       â† agente di ripristino
â”œâ”€â”€ keys/                â† chiavi GPG (NON caricare su git!)
â”œâ”€â”€ backups/local/       â† storage locale simulato
â”œâ”€â”€ test-data/           â† file di test
â”œâ”€â”€ .env                 â† credenziali (NON caricare su git!)
â”œâ”€â”€ .gitignore
â””â”€â”€ package.json
```

Crea subito il `.gitignore`:

```bash
cat > .gitignore << 'EOF'
# Mai committare chiavi o credenziali!
keys/
.env
backups/

# Node
node_modules/
EOF
```

---

## Esercitazione Pratica 1 - Setup e Struttura del Progetto

### Step 1: Generare le Chiavi di Backup

Crea il file `src/keygen.js`:

```javascript
// src/keygen.js
// Genera la coppia di chiavi dedicata al backup

const openpgp = require('openpgp');
const fs      = require('fs');
const path    = require('path');
const readline = require('readline');

async function chiediPassphrase() {
  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  return new Promise(resolve => {
    // Nasconde l'input (disabilita echo)
    process.stdout.write('Inserisci la passphrase per la chiave di backup: ');
    process.stdin.setRawMode(true);
    let pass = '';
    process.stdin.on('data', ch => {
      ch = ch.toString();
      if (ch === '\n' || ch === '\r' || ch === '\u0003') {
        process.stdin.setRawMode(false);
        rl.close();
        console.log('');
        resolve(pass);
      } else {
        pass += ch;
        process.stdout.write('*');
      }
    });
  });
}

async function generaChiaviBackup() {
  const nome  = process.argv[2] || 'Backup Agent';
  const email = process.argv[3] || 'backup@localhost';

  console.log(`\nğŸ”‘ Generazione chiavi di backup per: ${nome} <${email}>\n`);

  const passphrase = await chiediPassphrase();
  if (passphrase.length < 12) {
    console.error('âŒ La passphrase deve essere di almeno 12 caratteri.');
    process.exit(1);
  }

  console.log('\nâ³ Generazione in corso (ECC Curve25519)...');

  const { privateKey, publicKey, revocationCertificate } = await openpgp.generateKey({
    type: 'ecc',
    curve: 'curve25519',
    userIDs: [{ name: nome, email }],
    passphrase,
    format: 'armored',
  });

  // Salva i file nella cartella keys/
  const keysDir = path.join(__dirname, '..', 'keys');
  fs.writeFileSync(path.join(keysDir, 'backup_pub.asc'),   publicKey);
  fs.writeFileSync(path.join(keysDir, 'backup_priv.asc'),  privateKey);
  fs.writeFileSync(path.join(keysDir, 'revocation.asc'),   revocationCertificate);
  // Salva la passphrase in .env (NON committare!)
  fs.appendFileSync('.env', `\nBACKUP_PASSPHRASE="${passphrase}"\n`);

  console.log('\nâœ… Chiavi generate e salvate in keys/');
  console.log('   backup_pub.asc   â€” chiave pubblica (puoi condividerla)');
  console.log('   backup_priv.asc  â€” chiave PRIVATA  (tenere offline e sicura!)');
  console.log('   revocation.asc   â€” certificato di revoca (conservare offline)');
  console.log('\nâš ï¸  La passphrase Ã¨ stata salvata in .env');
  console.log('   In produzione usa un secret manager (AWS Secrets Manager, Vault...)');
}

generaChiaviBackup().catch(err => {
  console.error('Errore:', err.message);
  process.exit(1);
});
```

```bash
node src/keygen.js "Mario Rossi" "mario.rossi@scuola.it"
```

---

### Step 2: Creare i File di Test

```bash
# Crea qualche file di test che simula dati da backuppare
echo "Report mensile gennaio 2026" > test-data/report_gennaio.txt
echo "username: admin\npassword: S3cur3P@ss!" > test-data/credenziali.txt
dd if=/dev/urandom bs=1024 count=512 2>/dev/null | base64 > test-data/archivio_clienti.csv
echo '{"api_key":"abc123","secret":"xyz789","endpoint":"https://api.azienda.it"}' > test-data/config.json

ls -lh test-data/
```

---

### Step 3: Verificare la Configurazione

Crea il file `.env` (aggiungi le variabili base â€” la passphrase verrÃ  aggiunta da `keygen.js`):

```bash
cat > .env << 'EOF'
# Storage backend: 'local' oppure 's3'
STORAGE_BACKEND=local
LOCAL_BACKUP_DIR=./backups/local

# AWS S3 (solo se STORAGE_BACKEND=s3)
AWS_REGION=eu-west-1
AWS_BUCKET_NAME=il-mio-bucket-backup
# AWS_ACCESS_KEY_ID e AWS_SECRET_ACCESS_KEY non inserire qui:
# usa ~/.aws/credentials oppure IAM Role

# Backup
BACKUP_KEY_ID=backup@localhost
EOF
```

---

## Esercitazione Pratica 2 - Motore di Cifratura e Decifratura

### Step 1: Il Modulo Crypto

Crea il file `src/crypto.js`:

```javascript
// src/crypto.js
// Motore crittografico: cifra/decifra file con OpenPGP.js
// Gestisce sia file piccoli (in memoria) che grandi (stream)

const openpgp = require('openpgp');
const fs      = require('fs');
const crypto  = require('crypto');
const path    = require('path');

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Carica la chiave pubblica da file
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function caricaChiavePubblica(keyFile) {
  const armoredKey = fs.readFileSync(keyFile, 'utf8');
  return openpgp.readKey({ armoredKey });
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Carica e decifra la chiave privata (richiede passphrase)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function caricaChiavePrivata(keyFile, passphrase) {
  const armoredKey = fs.readFileSync(keyFile, 'utf8');
  const encPrivKey = await openpgp.readPrivateKey({ armoredKey });
  return openpgp.decryptKey({ privateKey: encPrivKey, passphrase });
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Calcola lo SHA-256 di un file (per verifica integritÃ )
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function calcolaHashFile(filePath) {
  return new Promise((resolve, reject) => {
    const hash   = crypto.createHash('sha256');
    const stream = fs.createReadStream(filePath);
    stream.on('data', chunk => hash.update(chunk));
    stream.on('end',  ()    => resolve(hash.digest('hex')));
    stream.on('error', reject);
  });
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Cifra un file con la chiave pubblica
// Restituisce: { encryptedPath, originalHash, encryptedSize }
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function cifraFile(inputPath, outputPath, publicKey) {
  console.log(`  ğŸ” Cifratura: ${path.basename(inputPath)}`);

  // Calcola hash del file originale (per verifica integritÃ  al ripristino)
  const originalHash = await calcolaHashFile(inputPath);

  // Leggi il file (per file grandi usare stream â€” vedi modulo avanzato)
  const fileBuffer = fs.readFileSync(inputPath);
  const fileStats  = fs.statSync(inputPath);

  // Crea il messaggio binario
  const message = await openpgp.createMessage({
    binary: fileBuffer,
    filename: path.basename(inputPath),
    date: fileStats.mtime,
  });

  // Cifra con la chiave pubblica (OpenPGP.js usa internamente AES-256)
  const encrypted = await openpgp.encrypt({
    message,
    encryptionKeys: publicKey,
    format: 'armored',       // output ASCII â†’ piÃ¹ facile da gestire
  });

  fs.writeFileSync(outputPath, encrypted);
  const encryptedSize = fs.statSync(outputPath).size;

  console.log(`  âœ… Cifrato â†’ ${path.basename(outputPath)} (${formatSize(encryptedSize)})`);

  return {
    encryptedPath: outputPath,
    originalHash,
    originalSize: fileStats.size,
    encryptedSize,
  };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Decifra un file con la chiave privata
// Restituisce: { outputPath, decryptedHash }
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function decifraFile(encryptedPath, outputPath, privateKey, expectedHash = null) {
  console.log(`  ğŸ”“ Decifratura: ${path.basename(encryptedPath)}`);

  const armoredMessage = fs.readFileSync(encryptedPath, 'utf8');
  const message        = await openpgp.readMessage({ armoredMessage });

  const { data: decryptedBuffer } = await openpgp.decrypt({
    message,
    decryptionKeys: privateKey,
    format: 'binary',     // restituisce Buffer, non stringa
  });

  // Scrivi il file decifrato
  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  fs.writeFileSync(outputPath, Buffer.from(decryptedBuffer));

  // Verifica integritÃ  se Ã¨ stato fornito l'hash atteso
  const decryptedHash = await calcolaHashFile(outputPath);

  if (expectedHash) {
    if (decryptedHash === expectedHash) {
      console.log(`  âœ… IntegritÃ  verificata: hash SHA-256 corrispondente`);
    } else {
      console.error(`  âŒ ATTENZIONE: hash SHA-256 NON corrispondente!`);
      console.error(`     Atteso:   ${expectedHash}`);
      console.error(`     Ottenuto: ${decryptedHash}`);
      throw new Error(`IntegritÃ  compromessa per il file ${path.basename(outputPath)}`);
    }
  }

  return { outputPath, decryptedHash };
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Utility: formatta dimensione file
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function formatSize(bytes) {
  if (bytes < 1024)       return `${bytes} B`;
  if (bytes < 1024**2)    return `${(bytes/1024).toFixed(1)} KB`;
  if (bytes < 1024**3)    return `${(bytes/1024**2).toFixed(1)} MB`;
  return                         `${(bytes/1024**3).toFixed(2)} GB`;
}

module.exports = { caricaChiavePubblica, caricaChiavePrivata, cifraFile, decifraFile, calcolaHashFile, formatSize };
```

---

### Step 2: Test del Motore Crittografico

Crea il file `src/test_crypto.js`:

```javascript
// src/test_crypto.js
// Test rapido del modulo crypto

require('dotenv').config();
const path   = require('path');
const fs     = require('fs');
const crypto = require('./crypto');

async function testCrypto() {
  const pubKeyFile  = path.join(__dirname, '..', 'keys', 'backup_pub.asc');
  const privKeyFile = path.join(__dirname, '..', 'keys', 'backup_priv.asc');
  const passphrase  = process.env.BACKUP_PASSPHRASE;

  console.log('=== Test Motore Crittografico ===\n');

  // Carica le chiavi
  const pubKey  = await crypto.caricaChiavePubblica(pubKeyFile);
  const privKey = await crypto.caricaChiavePrivata(privKeyFile, passphrase);
  console.log('âœ… Chiavi caricate\n');

  // Cifra il file di test
  const inputFile     = 'test-data/report_gennaio.txt';
  const encryptedFile = 'backups/local/test_report.pgp';

  const { originalHash } = await crypto.cifraFile(inputFile, encryptedFile, pubKey);
  console.log(`  Hash originale: ${originalHash}\n`);

  // Decifra e verifica
  const outputFile = 'backups/local/restored_report.txt';
  await crypto.decifraFile(encryptedFile, outputFile, privKey, originalHash);

  // Confronto finale
  const contenutoOriginale  = fs.readFileSync(inputFile, 'utf8');
  const contenutoRipristinato = fs.readFileSync(outputFile, 'utf8');
  console.log(`\nContenuto originale:    "${contenutoOriginale.trim()}"`);
  console.log(`Contenuto ripristinato: "${contenutoRipristinato.trim()}"`);
  console.log(`\n${contenutoOriginale === contenutoRipristinato ? 'âœ… TEST SUPERATO' : 'âŒ TEST FALLITO'}`);
}

testCrypto().catch(console.error);
```

```bash
node src/test_crypto.js
```

Output atteso:
```
=== Test Motore Crittografico ===

âœ… Chiavi caricate

  ğŸ” Cifratura: report_gennaio.txt
  âœ… Cifrato â†’ test_report.pgp (1.8 KB)
  Hash originale: 3a4f8b...

  ğŸ”“ Decifratura: test_report.pgp
  âœ… IntegritÃ  verificata: hash SHA-256 corrispondente

Contenuto originale:    "Report mensile gennaio 2026"
Contenuto ripristinato: "Report mensile gennaio 2026"

âœ… TEST SUPERATO
```

---

## Esercitazione Pratica 3 - Backend di Storage Locale e S3

Il modulo `storage.js` astrae la destinazione del backup: lo stesso codice funziona sia in locale che su AWS S3.

### Step 1: Storage Abstraction Layer

Crea il file `src/storage.js`:

```javascript
// src/storage.js
// Astrazione dello storage: supporta backend locale e AWS S3
// Aggiungere altri backend (Google Cloud, Azure) senza modificare il codice chiamante

const fs   = require('fs');
const path = require('path');

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// BACKEND LOCALE
// Salva i file in una directory locale
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class LocalStorage {
  constructor(baseDir) {
    this.baseDir = baseDir;
    fs.mkdirSync(baseDir, { recursive: true });
    console.log(`ğŸ“ Storage locale: ${path.resolve(baseDir)}`);
  }

  async upload(localFile, remotePath) {
    const dest = path.join(this.baseDir, remotePath);
    fs.mkdirSync(path.dirname(dest), { recursive: true });
    fs.copyFileSync(localFile, dest);
    console.log(`  ğŸ“¤ Upload locale: ${remotePath}`);
    return remotePath;
  }

  async download(remotePath, localFile) {
    const src = path.join(this.baseDir, remotePath);
    if (!fs.existsSync(src)) {
      throw new Error(`File non trovato nello storage: ${remotePath}`);
    }
    fs.mkdirSync(path.dirname(localFile), { recursive: true });
    fs.copyFileSync(src, localFile);
    console.log(`  ğŸ“¥ Download locale: ${remotePath}`);
    return localFile;
  }

  async list(prefix = '') {
    const dir = path.join(this.baseDir, prefix);
    if (!fs.existsSync(dir)) return [];
    return fs.readdirSync(dir).map(f => path.join(prefix, f));
  }

  async delete(remotePath) {
    const fullPath = path.join(this.baseDir, remotePath);
    if (fs.existsSync(fullPath)) fs.unlinkSync(fullPath);
    console.log(`  ğŸ—‘ï¸  Eliminato: ${remotePath}`);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// BACKEND AWS S3
// Richiede: npm install @aws-sdk/client-s3
// Credenziali: ~/.aws/credentials oppure variabili d'ambiente
// AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_REGION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class S3Storage {
  constructor(bucketName, region = 'eu-west-1') {
    const { S3Client, PutObjectCommand, GetObjectCommand,
            ListObjectsV2Command, DeleteObjectCommand } = require('@aws-sdk/client-s3');
    this.client = new S3Client({ region });
    this.bucket = bucketName;
    this.S3Cmds = { PutObjectCommand, GetObjectCommand,
                    ListObjectsV2Command, DeleteObjectCommand };
    console.log(`â˜ï¸  Storage S3: s3://${bucketName} (${region})`);
  }

  async upload(localFile, remotePath) {
    const fileStream = require('fs').createReadStream(localFile);
    const fileSize   = require('fs').statSync(localFile).size;

    const cmd = new this.S3Cmds.PutObjectCommand({
      Bucket: this.bucket,
      Key: remotePath,
      Body: fileStream,
      ContentLength: fileSize,
      // Metadata non cifrata: solo chiave ID (non il contenuto!)
      Metadata: { 'x-backup-engine': 'pgp-e2e', 'x-encrypted': 'true' },
    });

    await this.client.send(cmd);
    console.log(`  ğŸ“¤ Upload S3: s3://${this.bucket}/${remotePath}`);
    return `s3://${this.bucket}/${remotePath}`;
  }

  async download(remotePath, localFile) {
    const cmd = new this.S3Cmds.GetObjectCommand({
      Bucket: this.bucket,
      Key: remotePath,
    });

    const { Body } = await this.client.send(cmd);
    require('fs').mkdirSync(require('path').dirname(localFile), { recursive: true });

    // Scrivi lo stream sul file locale
    await new Promise((resolve, reject) => {
      const ws = require('fs').createWriteStream(localFile);
      Body.pipe(ws);
      ws.on('finish', resolve);
      ws.on('error', reject);
    });

    console.log(`  ğŸ“¥ Download S3: ${remotePath}`);
    return localFile;
  }

  async list(prefix = '') {
    const cmd = new this.S3Cmds.ListObjectsV2Command({
      Bucket: this.bucket,
      Prefix: prefix,
    });
    const { Contents = [] } = await this.client.send(cmd);
    return Contents.map(obj => obj.Key);
  }

  async delete(remotePath) {
    const cmd = new this.S3Cmds.DeleteObjectCommand({
      Bucket: this.bucket,
      Key: remotePath,
    });
    await this.client.send(cmd);
    console.log(`  ğŸ—‘ï¸  Eliminato da S3: ${remotePath}`);
  }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Factory: crea il backend giusto in base alla configurazione
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function creaStorage(config = {}) {
  const backend = config.backend || process.env.STORAGE_BACKEND || 'local';

  if (backend === 's3') {
    const bucket = config.bucket || process.env.AWS_BUCKET_NAME;
    const region = config.region || process.env.AWS_REGION || 'eu-west-1';
    if (!bucket) throw new Error('AWS_BUCKET_NAME non configurato');
    return new S3Storage(bucket, region);
  }

  // Default: storage locale
  const dir = config.dir || process.env.LOCAL_BACKUP_DIR || './backups/local';
  return new LocalStorage(dir);
}

module.exports = { creaStorage, LocalStorage, S3Storage };
```

---

### Step 2: Test dello Storage Locale

```javascript
// src/test_storage.js
require('dotenv').config();
const { creaStorage } = require('./storage');
const fs = require('fs');

async function testStorage() {
  console.log('=== Test Storage Backend ===\n');

  const storage = creaStorage({ backend: 'local' });

  // Upload
  fs.writeFileSync('/tmp/test_upload.txt', 'Contenuto di test per lo storage');
  await storage.upload('/tmp/test_upload.txt', 'data/test_upload.txt');

  // List
  const files = await storage.list('data');
  console.log('File nel bucket:', files);

  // Download
  await storage.download('data/test_upload.txt', '/tmp/test_download.txt');
  const contenuto = fs.readFileSync('/tmp/test_download.txt', 'utf8');
  console.log('Contenuto scaricato:', contenuto);

  // Delete
  await storage.delete('data/test_upload.txt');
  console.log('\nâœ… Test storage superato');
}

testStorage().catch(console.error);
```

```bash
node src/test_storage.js
```

---

## Esercitazione Pratica 4 - Agente di Backup Completo

### Step 1: Gestione del Manifest

Il **manifest** Ã¨ un file JSON che registra tutti i file del backup con metadati e hash. Ãˆ cifrato prima del caricamento.

Crea il file `src/manifest.js`:

```javascript
// src/manifest.js
// Gestisce il manifest cifrato del backup

const openpgp = require('openpgp');
const crypto  = require('crypto');
const path    = require('path');
const fs      = require('fs');

// Crea un nuovo manifest
function creaManifest(backupId, label = '') {
  return {
    version: '1.0',
    backupId,
    label,
    createdAt: new Date().toISOString(),
    files: [],           // { originalPath, remotePath, hash, size, encryptedSize, timestamp }
    totalFiles: 0,
    totalOriginalSize: 0,
    totalEncryptedSize: 0,
  };
}

// Aggiunge una entry di file al manifest
function aggiungiFileAlManifest(manifest, entry) {
  manifest.files.push({
    originalPath:  entry.originalPath,
    remotePath:    entry.remotePath,
    hash:          entry.originalHash,
    size:          entry.originalSize,
    encryptedSize: entry.encryptedSize,
    timestamp:     new Date().toISOString(),
  });
  manifest.totalFiles++;
  manifest.totalOriginalSize  += entry.originalSize  || 0;
  manifest.totalEncryptedSize += entry.encryptedSize || 0;
}

// Salva il manifest cifrato su un file temporaneo
async function salvaManifestCifrato(manifest, tmpFile, publicKey) {
  const json      = JSON.stringify(manifest, null, 2);
  const message   = await openpgp.createMessage({ text: json });
  const encrypted = await openpgp.encrypt({
    message,
    encryptionKeys: publicKey,
    format: 'armored',
  });
  fs.writeFileSync(tmpFile, encrypted);
  return tmpFile;
}

// Legge e decifra un manifest
async function leggiManifestCifrato(encryptedFile, privateKey) {
  const armoredMessage = fs.readFileSync(encryptedFile, 'utf8');
  const message        = await openpgp.readMessage({ armoredMessage });
  const { data }       = await openpgp.decrypt({
    message,
    decryptionKeys: privateKey,
  });
  return JSON.parse(data);
}

// Genera un ID backup basato su data e ora
function generaBackupId() {
  const now = new Date();
  return `backup_${now.getFullYear()}${String(now.getMonth()+1).padStart(2,'0')}${String(now.getDate()).padStart(2,'0')}_${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}${String(now.getSeconds()).padStart(2,'0')}`;
}

// Genera un nome file remoto randomizzato (nasconde la struttura originale)
function generaNomeRemoto(originalPath) {
  const ext = '.pgp';
  const rand = crypto.randomBytes(8).toString('hex');
  return `data/${rand}${ext}`;
}

module.exports = {
  creaManifest, aggiungiFileAlManifest,
  salvaManifestCifrato, leggiManifestCifrato,
  generaBackupId, generaNomeRemoto,
};
```

---

### Step 2: L'Agente di Backup

Crea il file `src/backup.js`:

```javascript
// src/backup.js
// Agente di backup: scansiona, cifra e carica ogni file

require('dotenv').config();
const fs      = require('fs');
const path    = require('path');
const os      = require('os');
const crypto  = require('./crypto');
const storage = require('./storage');
const manifest = require('./manifest');

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Scansiona ricorsivamente una directory
// Restituisce un array di percorsi assoluti
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function scansionaDirectory(dir, esclusioni = ['.git', 'node_modules']) {
  const files = [];
  function leggiRicorsivo(currentDir) {
    for (const item of fs.readdirSync(currentDir)) {
      if (esclusioni.includes(item)) continue;
      const fullPath = path.join(currentDir, item);
      if (fs.statSync(fullPath).isDirectory()) {
        leggiRicorsivo(fullPath);
      } else {
        files.push(fullPath);
      }
    }
  }
  leggiRicorsivo(dir);
  return files;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Esegui il backup di una directory
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function eseguiBackup(sourceDir, opzioni = {}) {
  const {
    label       = '',
    exclude     = ['.git', 'node_modules', '.env'],
    pubKeyFile  = path.join(__dirname, '..', 'keys', 'backup_pub.asc'),
    storageConf = {},
  } = opzioni;

  console.log('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘        AGENTE DI BACKUP E2E          â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  console.log(`ğŸ“‚ Sorgente: ${path.resolve(sourceDir)}`);

  const backupId  = manifest.generaBackupId();
  const startTime = Date.now();

  // Carica la chiave pubblica
  const pubKey = await crypto.caricaChiavePubblica(pubKeyFile);
  const store  = storage.creaStorage(storageConf);

  // Crea il manifest
  const bkManifest = manifest.creaManifest(backupId, label);

  // Scansiona i file
  const files = scansionaDirectory(sourceDir, exclude);
  console.log(`ğŸ“‹ File trovati: ${files.length}\n`);

  let filesOk = 0, filesErr = 0;

  for (const filePath of files) {
    try {
      // Percorso relativo (usato nel manifest)
      const relativePath = path.relative(sourceDir, filePath);

      // Nome remoto randomizzato
      const remotePath = manifest.generaNomeRemoto(relativePath);

      // File temporaneo per il file cifrato
      const tmpEncrypted = path.join(os.tmpdir(), `pgp_backup_${Date.now()}.pgp`);

      // Cifra il file
      const result = await crypto.cifraFile(filePath, tmpEncrypted, pubKey);

      // Carica sul backend di storage
      await store.upload(tmpEncrypted, remotePath);

      // Aggiungi al manifest
      manifest.aggiungiFileAlManifest(bkManifest, {
        originalPath:  relativePath,
        remotePath,
        originalHash:  result.originalHash,
        originalSize:  result.originalSize,
        encryptedSize: result.encryptedSize,
      });

      // Pulisci il file temporaneo
      fs.unlinkSync(tmpEncrypted);

      filesOk++;
    } catch (err) {
      console.error(`  âŒ Errore su ${filePath}: ${err.message}`);
      filesErr++;
    }
  }

  // Salva e carica il manifest cifrato
  const manifestId      = `${backupId}_manifest`;
  const manifestRemote  = `manifests/${manifestId}.json.pgp`;
  const manifestTmp     = path.join(os.tmpdir(), `${manifestId}.json.pgp`);

  await manifest.salvaManifestCifrato(bkManifest, manifestTmp, pubKey);
  await store.upload(manifestTmp, manifestRemote);
  fs.unlinkSync(manifestTmp);

  const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);

  console.log('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘           BACKUP COMPLETATO           â•‘');
  console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
  console.log(`â•‘  ID:      ${backupId.padEnd(27)}â•‘`);
  console.log(`â•‘  âœ… OK:   ${String(filesOk).padEnd(27)}â•‘`);
  console.log(`â•‘  âŒ Err:  ${String(filesErr).padEnd(27)}â•‘`);
  console.log(`â•‘  â±ï¸  Tempo: ${elapsed}s${' '.repeat(24 - elapsed.length)}â•‘`);
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
  console.log(`ğŸ“‹ Manifest: ${manifestRemote}\n`);

  return { backupId, manifestRemote, filesOk, filesErr };
}

module.exports = { eseguiBackup };
```

---

### Step 3: Avviare il Backup

Crea il file `backup-cli.js` nella root del progetto:

```javascript
// backup-cli.js
// Interfaccia CLI per eseguire il backup

require('dotenv').config();
const path = require('path');
const args = require('minimist')(process.argv.slice(2));
const { eseguiBackup } = require('./src/backup');

const sourceDir = args._[0] || './test-data';
const label     = args.label || args.l || 'Backup manuale';
const backend   = args.backend || process.env.STORAGE_BACKEND || 'local';

console.log(`\nAvvio backup di: ${sourceDir}`);
console.log(`Backend storage: ${backend}`);
console.log(`Etichetta: ${label}\n`);

eseguiBackup(sourceDir, {
  label,
  storageConf: { backend },
}).catch(err => {
  console.error('Errore fatale:', err.message);
  process.exit(1);
});
```

```bash
# Esegui il backup della directory test-data
node backup-cli.js ./test-data --label "Backup lezione SIS3"
```

Output atteso:
```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘        AGENTE DI BACKUP E2E          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“‚ Sorgente: /ws/backup-e2e/test-data
ğŸ“‹ File trovati: 4

  ğŸ” Cifratura: report_gennaio.txt
  âœ… Cifrato â†’ b3a1f2e4c5d6.pgp (1.8 KB)
  ğŸ“¤ Upload locale: data/b3a1f2...pgp

  ğŸ” Cifratura: credenziali.txt
  âœ… Cifrato â†’ 9d7e2b4a1f3c.pgp (1.9 KB)
  ğŸ“¤ Upload locale: data/9d7e2b...pgp
  ...

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           BACKUP COMPLETATO          â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  ID:      backup_20260226_143512     â•‘
â•‘  âœ… OK:   4                         â•‘
â•‘  âŒ Err:  0                         â•‘
â•‘  â±ï¸  Tempo: 1.3s                    â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“‹ Manifest: manifests/backup_20260226_143512_manifest.json.pgp
```

---

## Esercitazione Pratica 5 - Ripristino e Verifica IntegritÃ 

### Step 1: L'Agente di Ripristino

Crea il file `src/restore.js`:

```javascript
// src/restore.js
// Agente di ripristino: scarica, decifra e verifica ogni file del backup

require('dotenv').config();
const fs       = require('fs');
const path     = require('path');
const os       = require('os');
const readline = require('readline');
const crypto   = require('./crypto');
const storage  = require('./storage');
const manifest = require('./manifest');

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Chiedi la passphrase in modo sicuro (nasconde input)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function chiediPassphrase(prompt = 'Passphrase chiave privata: ') {
  // In ambiente CI/automatico, leggi da .env
  if (process.env.BACKUP_PASSPHRASE) return process.env.BACKUP_PASSPHRASE;

  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  return new Promise(resolve => {
    process.stdout.write(prompt);
    process.stdin.setRawMode?.(true);
    let pass = '';
    process.stdin.on('data', ch => {
      ch = ch.toString();
      if (ch === '\n' || ch === '\r' || ch === '\u0003') {
        process.stdin.setRawMode?.(false);
        rl.close();
        console.log('');
        resolve(pass);
      } else {
        pass += ch;
        process.stdout.write('*');
      }
    });
  });
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Lista i backup disponibili
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function listaBackup(storageConf = {}) {
  const store   = storage.creaStorage(storageConf);
  const objects = await store.list('manifests');
  const backups = objects.filter(f => f.endsWith('.pgp'));

  console.log('\nğŸ“š Backup disponibili:\n');
  if (backups.length === 0) {
    console.log('  (nessun backup trovato)');
    return [];
  }
  backups.forEach((b, i) => console.log(`  [${i+1}] ${path.basename(b)}`));
  console.log('');
  return backups;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Ripristina un intero backup
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function eseguiRipristino(manifestRemote, destDir, opzioni = {}) {
  const {
    privKeyFile  = path.join(__dirname, '..', 'keys', 'backup_priv.asc'),
    storageConf  = {},
    soloFile     = null,     // se impostato, ripristina solo questo percorso relativo
  } = opzioni;

  console.log('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘       AGENTE DI RIPRISTINO E2E       â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

  // Chiedi la passphrase
  const passphrase = await chiediPassphrase();
  const privKey    = await crypto.caricaChiavePrivata(privKeyFile, passphrase);
  console.log('âœ… Chiave privata sbloccata\n');

  const store = storage.creaStorage(storageConf);

  // Scarica e decifra il manifest
  const manifestTmp = path.join(os.tmpdir(), `restore_manifest_${Date.now()}.pgp`);
  console.log(`ğŸ“‹ Scarico manifest: ${manifestRemote}`);
  await store.download(manifestRemote, manifestTmp);
  const bkManifest = await manifest.leggiManifestCifrato(manifestTmp, privKey);
  fs.unlinkSync(manifestTmp);

  console.log(`\nğŸ“¦ Backup: ${bkManifest.backupId}`);
  console.log(`   Creato: ${new Date(bkManifest.createdAt).toLocaleString('it-IT')}`);
  console.log(`   File totali: ${bkManifest.totalFiles}`);
  console.log(`   Etichetta: ${bkManifest.label || 'â€”'}\n`);

  // Filtra i file se Ã¨ stato richiesto un ripristino selettivo
  const fileDaRipristinare = soloFile
    ? bkManifest.files.filter(f => f.originalPath.includes(soloFile))
    : bkManifest.files;

  if (fileDaRipristinare.length === 0) {
    console.log('âš ï¸  Nessun file corrispondente trovato nel manifest.');
    return;
  }

  let ok = 0, err = 0;
  const startTime = Date.now();

  for (const entry of fileDaRipristinare) {
    try {
      const tmpEncrypted = path.join(os.tmpdir(), `restore_${Date.now()}.pgp`);
      const outputPath   = path.join(destDir, entry.originalPath);

      // Scarica il file cifrato
      await store.download(entry.remotePath, tmpEncrypted);

      // Decifra con verifica integritÃ  (hash SHA-256)
      await crypto.decifraFile(tmpEncrypted, outputPath, privKey, entry.hash);

      // Pulisci
      fs.unlinkSync(tmpEncrypted);

      console.log(`  â†’ Ripristinato: ${entry.originalPath}`);
      ok++;
    } catch (e) {
      console.error(`  âŒ Errore ripristino ${entry.originalPath}: ${e.message}`);
      err++;
    }
  }

  const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);

  console.log('\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘          RIPRISTINO COMPLETATO       â•‘');
  console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
  console.log(`â•‘  âœ… OK:   ${String(ok).padEnd(27)}â•‘`);
  console.log(`â•‘  âŒ Err:  ${String(err).padEnd(27)}â•‘`);
  console.log(`â•‘  â±ï¸  Tempo: ${elapsed}s${' '.repeat(24 - elapsed.length)}â•‘`);
  console.log(`â•‘  ğŸ“‚ Dest: ${destDir.slice(0,27).padEnd(27)}â•‘`);
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
}

module.exports = { eseguiRipristino, listaBackup };
```

---

### Step 2: CLI di Ripristino

Crea il file `restore-cli.js` nella root:

```javascript
// restore-cli.js
// Interfaccia CLI per il ripristino

require('dotenv').config();
const path  = require('path');
const args  = require('minimist')(process.argv.slice(2));
const { eseguiRipristino, listaBackup } = require('./src/restore');

async function main() {
  const backend = args.backend || process.env.STORAGE_BACKEND || 'local';
  const storageConf = { backend };

  // ModalitÃ  lista
  if (args.list || args.l) {
    await listaBackup(storageConf);
    return;
  }

  // ModalitÃ  ripristino
  const manifestRemote = args.manifest || args.m;
  const destDir        = args.dest     || args.d || './backups/restored';
  const soloFile       = args.file     || args.f || null;

  if (!manifestRemote) {
    console.log('Uso:');
    console.log('  node restore-cli.js --list');
    console.log('  node restore-cli.js --manifest manifests/backup_xxx.json.pgp --dest ./ripristino');
    console.log('  node restore-cli.js --manifest ... --file credenziali.txt  (ripristino selettivo)');
    process.exit(1);
  }

  await eseguiRipristino(manifestRemote, destDir, { storageConf, soloFile });
}

main().catch(err => {
  console.error('Errore fatale:', err.message);
  process.exit(1);
});
```

---

### Step 3: Eseguire il Ripristino

```bash
# Elenca i backup disponibili
node restore-cli.js --list

# Ripristina un backup completo
node restore-cli.js \
  --manifest manifests/backup_20260226_143512_manifest.json.pgp \
  --dest ./backups/restored

# Ripristino selettivo di un singolo file
node restore-cli.js \
  --manifest manifests/backup_20260226_143512_manifest.json.pgp \
  --dest ./backups/restored \
  --file credenziali.txt
```

Output ripristino:
```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘       AGENTE DI RIPRISTINO E2E        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Passphrase chiave privata: ************
âœ… Chiave privata sbloccata

ğŸ“‹ Scarico manifest: manifests/backup_20260226_143512_manifest.json.pgp

ğŸ“¦ Backup: backup_20260226_143512
   Creato: 26/02/2026, 14:35:12
   File totali: 4
   Etichetta: Backup lezione SIS3

  ğŸ“¥ Download locale: data/b3a1f2...pgp
  ğŸ”“ Decifratura: b3a1f2...pgp
  âœ… IntegritÃ  verificata: hash SHA-256 corrispondente
  â†’ Ripristinato: report_gennaio.txt
  ...

â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘          RIPRISTINO COMPLETATO       â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘  âœ… OK:   4                          â•‘
â•‘  âŒ Err:  0                          â•‘
â•‘  â±ï¸  Tempo: 0.9s                     â•‘
â•‘  ğŸ“‚ Dest: ./backups/restored         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

### Step 4: Verificare i File Ripristinati

```bash
# Confronta il file originale con quello ripristinato
diff test-data/report_gennaio.txt backups/restored/report_gennaio.txt
echo "Diff exit code: $?"   # 0 = identici

# Verifica la struttura della directory ripristinata
ls -la backups/restored/

# Confronta gli hash SHA-256
sha256sum test-data/credenziali.txt backups/restored/credenziali.txt
```

Output atteso:
```
Diff exit code: 0
a1b2c3d4...  test-data/credenziali.txt
a1b2c3d4...  backups/restored/credenziali.txt
```

âœ… Hash identici â€” il file Ã¨ stato ripristinato senza alcuna modifica.

---

## Esercitazione Pratica 6 (OPZIONALE) - Backup Automatico con Scheduling

### Step 1: Backup Periodico con node-cron

```bash
npm install node-cron
```

Crea il file `src/scheduler.js`:

```javascript
// src/scheduler.js
// Esegue backup automatici secondo una schedulazione

require('dotenv').config();
const cron   = require('node-cron');
const path   = require('path');
const { eseguiBackup } = require('./backup');

const CONFIG = {
  sourceDir:   process.env.BACKUP_SOURCE_DIR   || './test-data',
  storageConf: { backend: process.env.STORAGE_BACKEND || 'local' },
  schedule:    process.env.BACKUP_SCHEDULE      || '0 2 * * *',  // ogni notte alle 02:00
};

console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
console.log('â•‘      BACKUP SCHEDULER AVVIATO        â•‘');
console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
console.log(`â•‘  Sorgente:  ${CONFIG.sourceDir.padEnd(27)}â•‘`);
console.log(`â•‘  Schedule:  ${CONFIG.schedule.padEnd(27)}â•‘`);
console.log(`â•‘  Storage:   ${CONFIG.storageConf.backend.padEnd(27)}â•‘`);
console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

// Esegui subito il primo backup (per verifica)
(async () => {
  console.log('â–¶ï¸  Eseguendo backup iniziale...');
  await eseguiBackup(CONFIG.sourceDir, {
    label: 'Backup iniziale scheduler',
    storageConf: CONFIG.storageConf,
  });
})();

// Pianifica i backup periodici
cron.schedule(CONFIG.schedule, async () => {
  console.log(`\nâ° Backup pianificato avviato: ${new Date().toLocaleString('it-IT')}`);
  try {
    await eseguiBackup(CONFIG.sourceDir, {
      label: `Backup automatico ${new Date().toISOString()}`,
      storageConf: CONFIG.storageConf,
    });
  } catch (err) {
    console.error('âŒ Backup pianificato fallito:', err.message);
    // In produzione: invia notifica email / Slack / webhook
  }
}, {
  scheduled: true,
  timezone: 'Europe/Rome',
});

console.log('ğŸ• Scheduler attivo. Premi Ctrl+C per uscire.\n');
```

```bash
node src/scheduler.js
```

### Step 2: Retention Policy â€” Eliminare i Backup Vecchi

```javascript
// src/retention.js
// Mantiene solo gli N backup piÃ¹ recenti, elimina i piÃ¹ vecchi

require('dotenv').config();
const { creaStorage } = require('./storage');

async function applicaRetentionPolicy(maxBackup = 7, storageConf = {}) {
  const store   = require('./storage').creaStorage(storageConf);
  const oggetti = await store.list('manifests');

  // Ordina per nome (timestamp nel nome â†’ ordine cronologico)
  const manifests = oggetti
    .filter(f => f.endsWith('.pgp'))
    .sort()
    .reverse();  // dal piÃ¹ recente al piÃ¹ vecchio

  console.log(`\nğŸ—‚ï¸  Retention policy: mantieni ${maxBackup} backup, trovati ${manifests.length}\n`);

  const daEliminare = manifests.slice(maxBackup);

  if (daEliminare.length === 0) {
    console.log('âœ… Nessun backup da eliminare.');
    return;
  }

  for (const manifest of daEliminare) {
    console.log(`ğŸ—‘ï¸  Elimino vecchio backup: ${manifest}`);
    await store.delete(manifest);
    // Nota: in un sistema completo occorre anche eliminare i file data/ associati
  }

  console.log(`\nâœ… Eliminati ${daEliminare.length} backup vecchi.`);
}

applicaRetentionPolicy(
  parseInt(process.env.BACKUP_RETENTION || '7'),
  { backend: process.env.STORAGE_BACKEND || 'local' }
).catch(console.error);
```

```bash
node src/retention.js
```

---

## Verifica e Troubleshooting

### Verificare il Contenuto del Bucket

```bash
# Storage locale
ls -lh backups/local/data/
ls -lh backups/local/manifests/

# Prova a leggere un file cifrato: deve essere illeggibile
cat backups/local/data/*.pgp | head -5
```

Output atteso (file cifrato = illeggibile):
```
-----BEGIN PGP MESSAGE-----

wcBMA3H7bP+...
```

### Simulare una Violazione del Cloud

```bash
# Scenario: un attaccante ha accesso fisico al bucket
# Tenta di leggere un file senza la chiave privata
cat backups/local/data/*.pgp
# â†’ vede solo testo cifrato incomprensibile âœ…

# Tenta di decifrare senza chiave privata
gpg --decrypt backups/local/data/*.pgp
# â†’ "No secret key" âœ…
```

### Problemi Comuni

#### 1. `Error: Incorrect key passphrase` al ripristino

**Causa**: la passphrase in `.env` non corrisponde a quella usata nella generazione.

**Soluzione:**
```bash
# Verifica la passphrase nel .env
grep BACKUP_PASSPHRASE .env

# Testa manualmente che la chiave privata si sblocchi
node -e "
  require('dotenv').config();
  const openpgp = require('openpgp');
  const fs = require('fs');
  openpgp.readPrivateKey({ armoredKey: fs.readFileSync('keys/backup_priv.asc','utf8') })
    .then(k => openpgp.decryptKey({ privateKey: k, passphrase: process.env.BACKUP_PASSPHRASE }))
    .then(() => console.log('âœ… Chiave sbloccata'))
    .catch(e => console.error('âŒ', e.message));
"
```

#### 2. `Error: ENOENT` â€” file non trovato al ripristino

**Causa**: il percorso nel manifest non corrisponde al file nello storage (es. file eliminato manualmente).

**Soluzione:**
```bash
# Verifica che i file indicati nel manifest esistano
ls backups/local/data/
# Confronta con i remotePath nel manifest decifrato (vedi comando sotto)
```

Per leggere il manifest:
```bash
gpg --decrypt backups/local/manifests/backup_*.json.pgp | python3 -m json.tool | head -40
```

#### 3. `Error: Integrity compromessa` â€” hash non corrispondente

**Causa**: il file Ã¨ stato corrotto o modificato durante il trasferimento/storage.

**Soluzione:**
```bash
# Riesegui il backup del file specifico
node backup-cli.js ./test-data --label "Backup correttivo"

# In un sistema di produzione: usa checksum S3 (Content-MD5)
# oppure verifica ETag S3 dopo ogni upload
```

#### 4. File `.pgp` nel bucket ha dimensione 0

**Causa**: errore silenzioso durante la scrittura del file temporaneo.

**Soluzione:**
```bash
# Aggiungi un controllo nel modulo backup dopo cifraFile:
const stats = fs.statSync(tmpEncrypted);
if (stats.size === 0) throw new Error('File cifrato vuoto: cifratura fallita');
```

#### 5. `Out of memory` su file di grandi dimensioni

**Causa**: il file viene letto interamente in memoria con `fs.readFileSync`.

**Soluzione** â€” usa stream:
```javascript
// Per file > 50 MB usare il supporto stream di OpenPGP.js
const { Web: WebStream } = require('@openpgp/web-stream-tools');
// Oppure usa openpgp.stream con ReadableStream di Node.js
// Documentazione: https://openpgpjs.org/openpgpjs/streaming.html
```

---

## Esercizi

### Esercizio 1: Backup di un Intero Progetto (â˜…â˜†â˜†)

1. Crea una directory `progetto-test/` con almeno 5 file di types diversi (`.txt`, `.json`, `.sh`, `.md`)
2. Esegui il backup con `backup-cli.js`
3. Esamina il contenuto di `backups/local/data/`: i nomi dei file sono randomizzati?
4. Decifra manualmente uno dei file `.pgp` con GPG CLI: corrisponde all'originale?

**Domande:**
- PerchÃ© i nomi dei file nel bucket sono randomizzati anzichÃ© usare il nome originale?
- Quali informazioni riesce a ricavare un attaccante che accede al bucket, pur non potendo decifrare i file?

### Esercizio 2: Verifica IntegritÃ  dopo Manomissione (â˜…â˜…â˜†)

1. Esegui un backup completo
2. Apri con un editor di testo un file `.pgp` nello storage locale e modifica un singolo carattere
3. Tenta il ripristino: il sistema rileva la manomissione?
4. Confronta il messaggio di errore con quello di una decifratura corretta
5. Modifica invece il file nel manifest cifrato: cosa succede al ripristino?

**Domande:**
- Cosa garantisce l'hash SHA-256 nel manifest che non garantisce giÃ  OpenPGP?
- Un hash SHA-256 nel manifest firmato digitalmente offrirebbe garanzie aggiuntive?

### Esercizio 3: Backup Differenziale (â˜…â˜…â˜…)

Modifica l'agente di backup per supportare la modalitÃ  **differenziale**: carica solo i file modificati dall'ultimo backup.

Suggerimento: confronta l'hash SHA-256 del file corrente con l'hash registrato nel manifest dell'ultimo backup.

```javascript
// Pseudocodice
const ultimoManifest = await caricaUltimoManifest(store, privKey);
const fileGiaBackuppati = new Map(
  ultimoManifest.files.map(f => [f.originalPath, f.hash])
);

for (const file of files) {
  const hashCorrente = await calcolaHashFile(file);
  if (fileGiaBackuppati.get(relativePath) === hashCorrente) {
    console.log(`  â­ï¸  Invariato, salto: ${relativePath}`);
    continue;  // non serve ricaricare
  }
  // Cifra e carica solo i file modificati
}
```

**Domande:**
- Quali vantaggi porta il backup differenziale in termini di storage e banda?
- Quali complessitÃ  aggiuntive introduce in fase di ripristino?

### Esercizio 4: Doppia Chiave â€” Backup e Recovery Agent (â˜…â˜…â˜…)

In un'azienda reale il backup Ã¨ gestito da un agente automatico, ma il ripristino puÃ² essere richiesto solo da un amministratore:

1. Genera due coppie di chiavi: `backup_agent` (per il backup automatico) e `admin_recovery` (per il ripristino)
2. Modifica `backup.js` per cifrare ogni file per **entrambe** le chiavi (multi-recipient)
3. Il backup automatico usa solo la chiave pubblica di `backup_agent`, mai la privata
4. Il ripristino usa la chiave privata di `admin_recovery`

**Domande:**
- PerchÃ© l'agente di backup non ha mai bisogno della chiave privata?
- Cosa succederebbe se la chiave privata dell'agente di backup venisse compromessa?

### Esercizio 5: Notifiche di Backup (â˜…â˜…â˜†)

Estendi lo scheduler per inviare notifiche al termine di ogni backup:

1. Installa `nodemailer` (`npm install nodemailer`)
2. Crea un file `src/notifiche.js` che invia un'email di riepilogo con: ID backup, numero file, dimensione totale, durata
3. Invia l'email **dopo** la cifratura â€” il corpo dell'email non deve contenere nomi di file o percorsi (solo statistiche aggregate)

**Domande:**
- PerchÃ© Ã¨ importante che le notifiche non rivelino nomi di file o percorsi?
- Come potresti cifrare il corpo dell'email di notifica con PGP?

---

## Riferimenti e Approfondimenti

### Documentazione Ufficiale
- [OpenPGP.js â€“ Documentazione](https://openpgpjs.org/)
- [AWS SDK for JavaScript v3 â€“ S3](https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-s3/)
- [AWS S3 â€“ Server-Side Encryption](https://docs.aws.amazon.com/AmazonS3/latest/userguide/serv-side-encryption.html)
- [node-cron â€“ Documentazione](https://github.com/node-cron/node-cron)

### Best Practice per Backup E2E
- La chiave privata non deve mai uscire dal dispositivo del proprietario
- Conserva una copia offline della chiave privata e del certificato di revoca
- Usa chiavi dedicate per il backup, separate da quelle usate per email o firma
- Implementa la retention policy per evitare l'accumulo illimitato di backup
- Monitora i backup: una notifica assente Ã¨ un segnale di problema
- Testa periodicamente il ripristino â€” un backup mai testato non Ã¨ un backup reale

### Comandi di Riferimento Rapido

```bash
# Genera chiavi di backup
node src/keygen.js "Nome Cognome" "email@dominio.it"

# Esegui backup
node backup-cli.js ./directory-da-backuppare --label "Descrizione"
node backup-cli.js ./directory --backend s3

# Lista backup
node restore-cli.js --list
node restore-cli.js --list --backend s3

# Ripristino completo
node restore-cli.js \
  --manifest manifests/backup_YYYYMMDD_HHMMSS_manifest.json.pgp \
  --dest ./ripristino

# Ripristino selettivo
node restore-cli.js \
  --manifest manifests/backup_xxx.json.pgp \
  --dest ./ripristino \
  --file nome_file.txt

# Retention policy (mantieni 7 backup)
BACKUP_RETENTION=7 node src/retention.js

# Scheduler automatico
node src/scheduler.js

# Verifica manuale con GPG
gpg --import keys/backup_priv.asc
gpg --decrypt backups/local/manifests/backup_xxx.json.pgp | python3 -m json.tool
```

---

## Conclusioni

Hai imparato a:
âœ… Comprendere la differenza tra SSE (server-side) e cifratura E2E lato client  
âœ… Costruire un motore crittografico con OpenPGP.js per file di qualsiasi dimensione  
âœ… Implementare un'astrazione storage che supporta backend locale e AWS S3  
âœ… Gestire un manifest cifrato come registro affidabile dei file backuppati  
âœ… Verificare l'integritÃ  dei file ripristinati tramite hash SHA-256  
âœ… Schedulare backup automatici con politica di retention  
âœ… Analizzare le minacce residue (metadata, nomi file, timing)  

La crittografia E2E applicata ai backup Ã¨ il principio architetturale alla base di servizi come **Tresorit**, **SpiderOak** e **ProtonDrive**: il cloud diventa uno storage untrusted su cui appoggiarsi senza affidargli le proprie chiavi.

---

**Autore**: Prof. Filippo Bilardo  
**Corso**: Sistemi e Reti 3  
**Data**: Febbraio 2026
