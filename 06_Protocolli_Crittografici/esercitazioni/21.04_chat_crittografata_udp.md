# Chat Crittografata End-to-End con UDP (`dgram`) e OpenPGP.js

In questa esercitazione costruirai una **chat testuale con crittografia end-to-end (E2E)** usando esclusivamente il modulo core **`dgram`** di Node.js (UDP) e la libreria OpenPGP.js. Le funzioni crittografiche sono le stesse giÃ  viste nell'esercitazione **21.02** (`generaChiavi`, `cifraEFirma`, `decifraEVerifica`), qui riusate senza modifiche.

## Obiettivi della Lezione

- Usare il modulo `dgram` di Node.js per creare server e client UDP
- Comprendere le differenze tra UDP e TCP in un'applicazione real-time
- Gestire il riconoscimento dei datagram con `reqId` (no connessione, no ACK automatico)
- Riusare il modulo `crypto-helper.js` dell'esercitazione 21.02 senza modifiche
- Costruire un server di relay blind che non puÃ² leggere i messaggi
- Analizzare il limite di dimensione dei datagram UDP e il suo impatto su PGP

## Introduzione teorica

### UDP vs TCP per una chat

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  TCP (net module)                                                   â”‚
â”‚  â”œâ”€â”€ Connessione permanente (3-way handshake)                       â”‚
â”‚  â”œâ”€â”€ Stream bidirezionale continuo                                  â”‚
â”‚  â”œâ”€â”€ Garanzia di consegna e ordine                                  â”‚
â”‚  â”œâ”€â”€ Frammentazione gestita: serve il buffer '\n'                   â”‚
â”‚  â””â”€â”€ Overhead: ACK, ritrasmissioni, stato di connessione            â”‚
â”‚                                                                     â”‚
â”‚  UDP (dgram module)  â† questa esercitazione                         â”‚
â”‚  â”œâ”€â”€ Senza connessione: ogni datagram Ã¨ indipendente                â”‚
â”‚  â”œâ”€â”€ No garanzia di consegna nÃ© di ordine                           â”‚
â”‚  â”œâ”€â”€ Ogni send() = un pacchetto atomico (no frammentazione)         â”‚
â”‚  â”œâ”€â”€ Limite payload: 65.507 byte per datagram                       â”‚
â”‚  â””â”€â”€ Overhead minimo: ideale per messaggi brevi e real-time         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Datagram come frammentazione naturale

Con TCP bisogna implementare un buffer di riga per ricomporre i messaggi. Con UDP ogni `socket.send()` Ã¨ un **datagram atomico**: il ricevente ottiene esattamente i byte inviati con quella singola chiamata, oppure niente. Non esistono problemi di frammentazione lato applicazione.

```
TCP:  send("ciao") + send(" mondo") â†’ potrebbe arrivare come "cia" + "o mondo"
UDP:  send("ciao") + send(" mondo") â†’ arriva "ciao" poi " mondo" (o niente)
```

### Limite dimensione e compatibilitÃ  con PGP

Il payload massimo di un datagram UDP su IPv4 Ã¨ **65.507 byte** (`65535 - 20 header IP - 8 header UDP`). I messaggi PGP armored hanno dimensioni tipiche:

| Contenuto | Dimensione tipica |
|-----------|------------------|
| Chiave pubblica ECC Curve25519 | ~700-800 byte |
| Messaggio cifrato (testo breve) | ~1.000-2.000 byte |
| Messaggio cifrato (testo lungo 1 KB) | ~2.000-3.000 byte |
| Messaggio cifrato (testo lungo 60 KB) | ~82.000 byte âš ï¸ |

Per messaggi di chat normali siamo **abbondantemente sotto il limite**. L'esercizio D in fondo mostra come gestire messaggi di grandi dimensioni con il chunking.

### Architettura del sistema

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     SERVER UDP (relay blind)                         â”‚
â”‚                     dgram.createSocket('udp4')  porta 3000           â”‚
â”‚                                                                      â”‚
â”‚   socket.on('message', (msg, rinfo) => { ... })                      â”‚
â”‚                                                                      â”‚
â”‚   keystore: Map<username, { address, port, publicKeyArmored }>       â”‚
â”‚   (rinfo.address + rinfo.port identificano il client mittente)       â”‚
â”‚                                                                      â”‚
â”‚   frame 'register'  â†’ salva indirizzo+porta+chiavePubblica           â”‚
â”‚   frame 'get_key'   â†’ risponde con chiave pubblica richiesta         â”‚
â”‚   frame 'message'   â†’ relay datagram cifrato al destinatario         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚ UDP datagram JSON
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                                        â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CLIENT Alice      â”‚                  â”‚  CLIENT Bob        â”‚
â”‚  dgram.createSocketâ”‚                  â”‚  dgram.createSocketâ”‚
â”‚  bind(porta casualeâ”‚                  â”‚  bind(porta casualeâ”‚
â”‚                    â”‚                  â”‚                    â”‚
â”‚  keypair_alice     â”‚                  â”‚  keypair_bob       â”‚
â”‚  (privata locale)  â”‚                  â”‚  (privata locale)  â”‚
â”‚                    â”‚                  â”‚                    â”‚
â”‚  1. Cifra con      â”‚  datagram JSON   â”‚  1. Decifra con    â”‚
â”‚     pubkey Bob     â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º â”‚     privkey Bob    â”‚
â”‚  2. Firma con      â”‚                  â”‚  2. Verifica firma â”‚
â”‚     privkey Alice  â”‚                  â”‚     pubkey Alice   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Flusso di una sessione

```
Alice (udp:54321)           Server (udp:3000)           Bob (udp:54322)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€           â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€           â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
{ register, alice, pubA } â”€â”€â–º
                             salva aliceâ†’54321           â—„â”€â”€ { register, bob, pubB }
                             salva bobâ†’54322
                         â—„â”€â”€ { registered }              â—„â”€â”€ { registered }
                         â—„â”€â”€ { users_online: [] }
                                              â—„â”€â”€â”€ { get_key, alice, reqId:1 }
                              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º { key_response, alice, pubA, reqId:1 }

{ get_key, bob, reqId:1 } â”€â”€â–º
                         â—„â”€â”€ { key_response, bob, pubB, reqId:1 }

openpgp.encrypt(msg, pubB)
openpgp.sign(cifrato, privA)
{ message, from:alice,
  to:bob, payload }       â”€â”€â–º
                             { message, from:alice,
                               payload, ts }         â”€â”€â–º openpgp.decrypt(payload, privB)
                                                         verify(firma, pubA) âœ…
                                                         "Ciao Bob!" â† decifrato
```

---

## Prerequisiti

- **Node.js** v18 o superiore â€” `node --version`
- **npm** v9 o superiore â€” `npm --version`
- Completamento di **21.02** (basi di OpenPGP.js)

---

## Setup del progetto

### Step 1: Struttura e dipendenze

Solo `openpgp` come dipendenza esterna. `dgram` e `readline` sono moduli core.

```bash
mkdir pgp-chat-udp && cd pgp-chat-udp
npm init -y
npm install openpgp
```

Struttura del progetto:

```
pgp-chat-udp/
â”œâ”€â”€ package.json
â”œâ”€â”€ crypto-helper.js   â† copiato/riusato dall'esercitazione 21.02
â”œâ”€â”€ server.js          â† server UDP relay blind
â””â”€â”€ client.js          â† client di chat E2E da terminale
```

---

## Implementazione

### Step 2: Modulo `crypto-helper.js` (riuso da 21.02)

Questo modulo Ã¨ **identico** a quello sviluppato nell'esercitazione 21.02. Copialo o ricrealo:

```javascript
// crypto-helper.js
// Funzioni PGP â€” riusate dall'esercitazione 21.02 senza modifiche

const openpgp = require('openpgp');

/**
 * Genera una coppia di chiavi ECC Curve25519.
 * @param {string} nome
 * @param {string} email
 * @param {string} passphrase
 * @returns {{ privateKeyArmored, publicKeyArmored }}
 */
async function generaChiavi(nome, email, passphrase) {
  const { privateKey, publicKey } = await openpgp.generateKey({
    type: 'ecc',
    curve: 'curve25519',
    userIDs: [{ name: nome, email }],
    passphrase,
    format: 'armored',
  });
  return { privateKeyArmored: privateKey, publicKeyArmored: publicKey };
}

/**
 * Cifra e firma un messaggio di testo.
 * @param {string} testo
 * @param {string} pubKeyArmored    - chiave pubblica destinatario (armored)
 * @param {string} privKeyArmored   - chiave privata mittente (armored)
 * @param {string} passphrase
 * @returns {string} blob PGP armored
 */
async function cifraEFirma(testo, pubKeyArmored, privKeyArmored, passphrase) {
  const chiaveDest = await openpgp.readKey({ armoredKey: pubKeyArmored });

  const chiavePrivLockata = await openpgp.readPrivateKey({ armoredKey: privKeyArmored });
  const chiavePriv = await openpgp.decryptKey({
    privateKey: chiavePrivLockata,
    passphrase,
  });

  const messaggio = await openpgp.createMessage({ text: testo });

  return openpgp.encrypt({
    message: messaggio,
    encryptionKeys: chiaveDest,
    signingKeys: chiavePriv,
  });
}

/**
 * Decifra e verifica la firma di un blob PGP armored.
 * @param {string} cifratoArmored
 * @param {string} privKeyArmored   - chiave privata destinatario (armored)
 * @param {string} passphrase
 * @param {string} pubKeyMittente   - chiave pubblica mittente per verifica firma
 * @returns {{ testo, firmaValida, mittente }}
 */
async function decifraEVerifica(cifratoArmored, privKeyArmored, passphrase, pubKeyMittente) {
  const chiavePrivLockata = await openpgp.readPrivateKey({ armoredKey: privKeyArmored });
  const chiavePriv = await openpgp.decryptKey({
    privateKey: chiavePrivLockata,
    passphrase,
  });

  const chiaveMittente = await openpgp.readKey({ armoredKey: pubKeyMittente });
  const messaggio = await openpgp.readMessage({ armoredMessage: cifratoArmored });

  const { data: testo, signatures } = await openpgp.decrypt({
    message: messaggio,
    decryptionKeys: chiavePriv,
    verificationKeys: chiaveMittente,
  });

  let firmaValida = false;
  try {
    await signatures[0].verified;
    firmaValida = true;
  } catch { /* firma assente o non valida */ }

  const mittente = chiaveMittente.getUserIDs()[0];
  return { testo, firmaValida, mittente };
}

module.exports = { generaChiavi, cifraEFirma, decifraEVerifica };
```

---

### Step 3: Server UDP relay blind

Il server **non conosce le chiavi private** di nessun utente. Usa `rinfo` (remote info) per sapere dove rispondere a ogni client.

Crea `server.js`:

```javascript
// server.js
// Server relay blind UDP â€” usa solo il modulo core 'dgram'

const dgram = require('dgram');

const PORT = 3000;

// keystore: username â†’ { address, port, publicKeyArmored }
const keystore = new Map();

const server = dgram.createSocket('udp4');

// â”€â”€ Funzione di invio â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function invia(obj, address, port) {
  const buf = Buffer.from(JSON.stringify(obj), 'utf8');
  server.send(buf, 0, buf.length, port, address, (err) => {
    if (err) console.error(`[!] Errore invio a ${address}:${port} â€” ${err.message}`);
  });
}

// Invia a tutti tranne l'utente indicato
function broadcast(obj, escludiUsername = null) {
  for (const [user, info] of keystore.entries()) {
    if (user !== escludiUsername) {
      invia(obj, info.address, info.port);
    }
  }
}

// â”€â”€ Gestione messaggi in arrivo â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
server.on('message', (msg, rinfo) => {
  // Ogni datagram Ã¨ un JSON completo â€” nessun buffer necessario
  let frame;
  try {
    frame = JSON.parse(msg.toString('utf8'));
  } catch {
    console.error(`[!] Datagram non JSON da ${rinfo.address}:${rinfo.port}`);
    return;
  }

  switch (frame.type) {

    // â”€â”€ REGISTRAZIONE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    case 'register': {
      const { username, publicKeyArmored } = frame;
      if (!username || !publicKeyArmored) {
        invia({ type: 'error', message: 'register: campi mancanti' }, rinfo.address, rinfo.port);
        return;
      }

      keystore.set(username, {
        address: rinfo.address,
        port: rinfo.port,
        publicKeyArmored,
      });

      console.log(`[register] ${username} da ${rinfo.address}:${rinfo.port}`);

      // Conferma al nuovo client
      invia({ type: 'registered', username }, rinfo.address, rinfo.port);

      // Lista utenti giÃ  online
      const online = [...keystore.keys()].filter((k) => k !== username);
      invia({ type: 'users_online', users: online }, rinfo.address, rinfo.port);

      // Notifica agli altri
      broadcast({ type: 'user_joined', username }, username);
      break;
    }

    // â”€â”€ RICHIESTA CHIAVE PUBBLICA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    case 'get_key': {
      const { username: target, reqId } = frame;
      const entry = keystore.get(target);

      if (!entry) {
        invia(
          { type: 'key_error', reqId, message: `'${target}' non trovato o offline` },
          rinfo.address, rinfo.port
        );
        return;
      }

      // La chiave pubblica non Ã¨ segreta â€” la passiamo liberamente
      invia(
        { type: 'key_response', reqId, username: target, publicKeyArmored: entry.publicKeyArmored },
        rinfo.address, rinfo.port
      );
      break;
    }

    // â”€â”€ RELAY MESSAGGIO CIFRATO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    case 'message': {
      const { to, from, payload } = frame;
      const dest = keystore.get(to);

      if (!dest) {
        invia({ type: 'error', message: `'${to}' non online` }, rinfo.address, rinfo.port);
        return;
      }

      // Il server vede: mittente, destinatario, dimensione del blob cifrato
      // NON vede il contenuto del messaggio
      console.log(`[msg] ${from} â”€â”€â–º ${to} (${payload.length} byte, cifrato)`);

      // Relay: spedisce il datagram cifrato al destinatario
      invia(
        { type: 'message', from, payload, timestamp: new Date().toISOString() },
        dest.address, dest.port
      );
      break;
    }

    default:
      invia({ type: 'error', message: `tipo sconosciuto: ${frame.type}` }, rinfo.address, rinfo.port);
  }
});

// â”€â”€ Avvio server â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
server.on('error', (err) => {
  console.error(`[!] Errore server: ${err.message}`);
  server.close();
});

server.bind(PORT, () => {
  const { address, port } = server.address();
  console.log(`ğŸ”’ Server relay UDP in ascolto su ${address}:${port}`);
  console.log('   Modulo: dgram (core Node.js) â€” nessuna dipendenza esterna.');
  console.log('   Il server NON puÃ² leggere i messaggi cifrati.\n');
});
```

---

### Step 4: Client UDP di chat E2E

Il client:
1. Crea un socket UDP e lo lega a una porta casuale (`bind(0)`)
2. Invia datagram JSON al server
3. Riceve datagram dal server (giÃ  instradati)
4. Usa `reqId` per abbinare le risposte `get_key` alle Promise pendenti

Crea `client.js`:

```javascript
// client.js
// Client di chat E2E â€” usa dgram (core), readline (core) e openpgp

const dgram    = require('dgram');
const readline = require('readline');
const { generaChiavi, cifraEFirma, decifraEVerifica } = require('./crypto-helper');

const SERVER_ADDRESS = '127.0.0.1';
const SERVER_PORT    = 3000;

// â”€â”€ Stato sessione â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let myUsername;
let myPublicKeyArmored;
let myPrivateKeyArmored;
let myPassphrase;
let destinatario = null;

// Keystore locale: username â†’ publicKeyArmored
const keystoreLocale = new Map();

// Pending get_key: reqId â†’ { resolve, reject, timeoutId }
let nextReqId = 1;
const pending = new Map();

// â”€â”€ Socket UDP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const socket = dgram.createSocket('udp4');

function invia(obj) {
  const buf = Buffer.from(JSON.stringify(obj), 'utf8');
  socket.send(buf, 0, buf.length, SERVER_PORT, SERVER_ADDRESS, (err) => {
    if (err) stampa(`âš ï¸  Errore invio: ${err.message}`);
  });
}

// â”€â”€ UI terminale â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
  terminal: false,
});

function prompt(domanda) {
  return new Promise((resolve) => {
    process.stdout.write(domanda);
    rl.once('line', resolve);
  });
}

function stampa(msg) {
  process.stdout.clearLine?.(0);
  process.stdout.cursorTo?.(0);
  console.log(msg);
  mostraPrompt();
}

function mostraPrompt() {
  if (destinatario) {
    process.stdout.write(`[${myUsername} â†’ ${destinatario}] `);
  }
}

// â”€â”€ Richiesta get_key asincrona (reqId per abbinare richiesta/risposta) â”€â”€â”€â”€â”€
function richiediChiave(username) {
  return new Promise((resolve, reject) => {
    const reqId = nextReqId++;

    // Timeout di 5 secondi: con UDP non c'Ã¨ garanzia di consegna
    const timeoutId = setTimeout(() => {
      if (pending.has(reqId)) {
        pending.delete(reqId);
        reject(new Error(`Timeout: nessuna risposta per la chiave di '${username}'`));
      }
    }, 5000);

    pending.set(reqId, { resolve, reject, timeoutId });
    invia({ type: 'get_key', username, reqId });
  });
}

// â”€â”€ Invio messaggio cifrato â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function inviaMess(testo) {
  if (!destinatario) {
    stampa('â„¹ï¸  Prima seleziona un destinatario con /chat <username>');
    return;
  }

  // Chiave pubblica del destinatario (con cache locale)
  let pubKeyDest = keystoreLocale.get(destinatario);
  if (!pubKeyDest) {
    try {
      stampa(`ğŸ”‘ Recupero chiave pubblica di ${destinatario}...`);
      pubKeyDest = await richiediChiave(destinatario);
    } catch (err) {
      stampa(`âŒ ${err.message}`);
      return;
    }
  }

  // Cifra e firma localmente â€” funzioni di crypto-helper.js (21.02)
  const payload = await cifraEFirma(
    testo,
    pubKeyDest,
    myPrivateKeyArmored,
    myPassphrase
  );

  // Invio al server come singolo datagram UDP
  invia({ type: 'message', from: myUsername, to: destinatario, payload });

  const ora = new Date().toLocaleTimeString('it-IT');
  stampa(`[${ora}] ğŸ“¤ Tu â†’ ${destinatario}: ${testo}`);
}

// â”€â”€ Gestione datagram in arrivo dal server â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
socket.on('message', async (msg, rinfo) => {
  let frame;
  try {
    frame = JSON.parse(msg.toString('utf8'));
  } catch {
    return; // datagram malformato, ignora
  }

  switch (frame.type) {

    case 'registered':
      // La Promise di registrazione Ã¨ risolta nel loop avvia()
      socket.emit('_registered', frame);
      break;

    case 'users_online':
      if (frame.users.length === 0) {
        stampa('ğŸ‘¥ Nessun altro utente online.');
      } else {
        stampa(`ğŸ‘¥ Utenti online: ${frame.users.join(', ')}`);
      }
      break;

    case 'user_joined':
      stampa(`ğŸŸ¢ ${frame.username} si Ã¨ connesso`);
      break;

    case 'user_left':
      stampa(`ğŸ”´ ${frame.username} si Ã¨ disconnesso`);
      keystoreLocale.delete(frame.username);
      break;

    case 'key_response': {
      const cb = pending.get(frame.reqId);
      if (cb) {
        clearTimeout(cb.timeoutId);
        pending.delete(frame.reqId);
        keystoreLocale.set(frame.username, frame.publicKeyArmored);
        cb.resolve(frame.publicKeyArmored);
      }
      break;
    }

    case 'key_error': {
      const cb = pending.get(frame.reqId);
      if (cb) {
        clearTimeout(cb.timeoutId);
        pending.delete(frame.reqId);
        cb.reject(new Error(frame.message));
      }
      break;
    }

    // â”€â”€ Messaggio cifrato in arrivo â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    case 'message': {
      const { from, payload, timestamp } = frame;
      try {
        // Recupera chiave pubblica del mittente per verifica firma
        let pubKeyMittente = keystoreLocale.get(from);
        if (!pubKeyMittente) {
          pubKeyMittente = await richiediChiave(from);
        }

        // Decifra e verifica â€” funzioni di crypto-helper.js (21.02)
        const { testo, firmaValida, mittente } = await decifraEVerifica(
          payload,
          myPrivateKeyArmored,
          myPassphrase,
          pubKeyMittente
        );

        const ora = new Date(timestamp).toLocaleTimeString('it-IT');
        const tag  = firmaValida ? 'âœ…' : 'âš ï¸ FIRMA NON VALIDA';
        stampa(`\n[${ora}] ğŸ“¨ ${mittente} ${tag}`);
        stampa(`  > ${testo}`);
      } catch (err) {
        stampa(`âš ï¸  Impossibile decifrare messaggio da ${from}: ${err.message}`);
      }
      break;
    }

    case 'error':
      stampa(`âš ï¸  Server: ${frame.message}`);
      break;
  }
});

socket.on('error', (err) => {
  stampa(`âŒ Errore socket: ${err.message}`);
  process.exit(1);
});

// â”€â”€ Registrazione â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function registra() {
  return new Promise((resolve) => {
    socket.once('_registered', resolve);
    invia({ type: 'register', username: myUsername, publicKeyArmored: myPublicKeyArmored });
  });
}

// â”€â”€ Loop comandi â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function leggiComandi() {
  stampa('\nğŸ“– Comandi:');
  stampa('  /chat <username>   â€” inizia chat con un utente');
  stampa('  /chiave <username> â€” mostra fingerprint chiave di un utente');
  stampa('  /esci              â€” esci\n');

  for await (const linea of rl) {
    const input = linea.trim();
    if (!input) continue;

    if (input.startsWith('/chat ')) {
      destinatario = input.slice(6).trim();
      stampa(`ğŸ’¬ Chat con ${destinatario}.`);
      mostraPrompt();

    } else if (input.startsWith('/chiave ')) {
      const user = input.slice(8).trim();
      try {
        const openpgp = require('openpgp');
        let pub = keystoreLocale.get(user);
        if (!pub) pub = await richiediChiave(user);
        const key = await openpgp.readKey({ armoredKey: pub });
        const fp  = key.getFingerprint().toUpperCase().match(/.{1,4}/g).join(' ');
        stampa(`ğŸ” ${user}: ${fp}`);
        stampa('   Confronta fuori banda (telefono) per escludere MITM.');
      } catch (err) {
        stampa(`âŒ ${err.message}`);
      }

    } else if (input === '/esci') {
      stampa('ğŸ‘‹ Uscita...');
      socket.close();
      process.exit(0);

    } else {
      await inviaMess(input);
    }
  }
}

// â”€â”€ Avvio â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function avvia() {
  console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
  console.log('â•‘  Chat E2E â€” dgram (UDP) + OpenPGP.js     â•‘');
  console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

  myUsername   = await prompt('ğŸ‘¤ Il tuo username: ');
  const email  = await prompt('ğŸ“§ La tua email:    ');
  myPassphrase = await prompt('ğŸ”‘ Passphrase:      ');

  console.log('\nâ³ Generazione chiavi ECC Curve25519...');
  // generaChiavi: funzione di crypto-helper.js, identica all'esercitazione 21.02
  const { privateKeyArmored, publicKeyArmored } = await generaChiavi(
    myUsername, email, myPassphrase
  );
  myPrivateKeyArmored = privateKeyArmored;
  myPublicKeyArmored  = publicKeyArmored;
  console.log('âœ… Chiavi generate.\n');

  // Bind a una porta casuale: necessario per ricevere datagram dal server
  await new Promise((resolve) => socket.bind(0, '0.0.0.0', resolve));
  const { port: localPort } = socket.address();
  console.log(`ğŸ”Œ Socket UDP locale: 0.0.0.0:${localPort}`);

  console.log('ğŸ“ Registrazione sul server...');
  await registra();
  console.log(`âœ… Registrato come "${myUsername}"\n`);

  await leggiComandi();
}

avvia().catch((err) => {
  console.error('Errore fatale:', err.message);
  process.exit(1);
});
```

---

## Esecuzione

### Avvia il server

```bash
# Terminale 1
node server.js
```

Output atteso:
```
ğŸ”’ Server relay UDP in ascolto su 0.0.0.0:3000
   Modulo: dgram (core Node.js) â€” nessuna dipendenza esterna.
   Il server NON puÃ² leggere i messaggi cifrati.
```

### Avvia due client in terminali separati

```bash
# Terminale 2
node client.js
```

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  Chat E2E â€” dgram (UDP) + OpenPGP.js     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ‘¤ Il tuo username: alice
ğŸ“§ La tua email:    alice@scuola.it
ğŸ”‘ Passphrase:      ***

â³ Generazione chiavi ECC Curve25519...
âœ… Chiavi generate.

ğŸ”Œ Socket UDP locale: 0.0.0.0:54321
ğŸ“ Registrazione sul server...
âœ… Registrato come "alice"
ğŸ‘¥ Nessun altro utente online.
```

```bash
# Terminale 3
node client.js
```

```
ğŸ‘¤ Il tuo username: bob
...
ğŸ”Œ Socket UDP locale: 0.0.0.0:54322
âœ… Registrato come "bob"
ğŸ‘¥ Utenti online: alice
```

Nel terminale di Alice:
```
ğŸŸ¢ bob si Ã¨ connesso
```

### Sessione di chat

**Terminal Alice:**
```
/chat bob
ğŸ’¬ Chat con bob.
[alice â†’ bob] Ciao Bob, questo messaggio Ã¨ cifrato!
ğŸ”‘ Recupero chiave pubblica di bob...
[14:32:05] ğŸ“¤ Tu â†’ bob: Ciao Bob, questo messaggio Ã¨ cifrato!
[alice â†’ bob]
```

**Terminal Bob:**
```
[14:32:05] ğŸ“¨ bob <bob@scuola.it> âœ…
  > Ciao Bob, questo messaggio Ã¨ cifrato!
```

**Terminal Server:**
```
[register] alice da 127.0.0.1:54321
[register] bob da 127.0.0.1:54322
[msg] alice â”€â”€â–º bob (1312 byte, cifrato)
```

Il server vede solo la dimensione del blob cifrato, mai il contenuto.

---

## Analisi: UDP vs TCP per questa applicazione

### Riassunto differenze nell'implementazione

| Aspetto | TCP (`net`) | UDP (`dgram`) |
|---------|-------------|---------------|
| Connessione | `net.createConnection()` | `socket.bind(0)` |
| Server | `net.createServer()` | `dgram.createSocket()` |
| Invio | `socket.write(data + '\n')` | `socket.send(buf, 0, len, port, addr)` |
| Ricezione server | `rinfo` non esiste â†’ ID da socket | `rinfo.address + rinfo.port` |
| Frammentazione | Buffer di riga necessario | Ogni datagram Ã¨ atomico âœ… |
| Garanzia consegna | SÃ¬ (TCP) | No â†’ timeout + reqId |
| Ordine messaggi | Garantito | Non garantito |
| Overhead | Maggiore | Minimo |
| Connessione persistente | SÃ¬ â†’ sa chi Ã¨ disconnesso | No â†’ timeout per rilevare offline |

### Cosa il server NON puÃ² fare

| Minaccia | Protetto? | Motivo |
|----------|-----------|--------|
| Leggere i messaggi | âœ… SÃ¬ | Payload cifrato con pubkey destinatario |
| Iniettare messaggi falsi | âœ… SÃ¬ | Ogni messaggio Ã¨ firmato |
| Impersonare un utente | âœ… SÃ¬ | Senza la chiave privata non puÃ² firmare |
| Vedere metadati (chiâ†’chi) | âŒ No | `from` e `to` nel datagram JSON |
| Attacchi MITM su get_key | âš ï¸ No | Il server potrebbe sostituire le chiavi |
| IP spoofing | âš ï¸ Parziale | UDP non autentica il mittente a livello rete |

---

## Limitazione UDP: dimensione datagram

Il limite pratico Ã¨ **65.507 byte** per datagram. Per messaggi di chat brevi Ã¨ piÃ¹ che sufficiente, ma Ã¨ bene capire cosa succede se si supera:

```javascript
// Test: misura la dimensione del datagram prima di inviarlo
async function inviaMess(testo) {
  const payload = await cifraEFirma(testo, pubKeyDest, myPrivateKeyArmored, myPassphrase);
  const frame   = JSON.stringify({ type: 'message', from: myUsername, to: destinatario, payload });
  const dimensione = Buffer.byteLength(frame, 'utf8');

  if (dimensione > 60_000) {
    stampa(`âŒ Messaggio troppo grande per un singolo datagram (${dimensione} byte)`);
    stampa('   Suggerimento: spezza il messaggio o usa TCP per file grandi.');
    return;
  }

  const buf = Buffer.from(frame, 'utf8');
  socket.send(buf, 0, buf.length, SERVER_PORT, SERVER_ADDRESS);
}
```

---

## Esercizi di approfondimento

### Esercizio A â€” Rilevamento disconnessione con heartbeat

UDP non ha il concetto di connessione: il server non sa se un client si Ã¨ disconnesso. Implementa un **heartbeat** periodico per rilevare i client offline.

```javascript
// client.js â€” invia ping ogni 15 secondi
setInterval(() => {
  invia({ type: 'ping', username: myUsername });
}, 15_000);

// server.js â€” timeout: elimina client che non pingano da >30s
const lastSeen = new Map(); // username â†’ timestamp

case 'ping': {
  lastSeen.set(frame.username, Date.now());
  break;
}

// Controlla ogni 10s
setInterval(() => {
  const ora = Date.now();
  for (const [user, ts] of lastSeen.entries()) {
    if (ora - ts > 30_000) {
      keystore.delete(user);
      lastSeen.delete(user);
      broadcast({ type: 'user_left', username: user });
      console.log(`[-] ${user} rimosso (heartbeat scaduto)`);
    }
  }
}, 10_000);
```

### Esercizio B â€” Persistenza chiavi su file

Modifica il client per salvare e ricaricare le chiavi, in modo da non doverle rigenerare a ogni avvio:

```javascript
const fs = require('fs');
const CHIAVI_FILE = `./${myUsername}_keys.json`;

if (fs.existsSync(CHIAVI_FILE)) {
  const { priv, pub } = JSON.parse(fs.readFileSync(CHIAVI_FILE, 'utf8'));
  myPrivateKeyArmored = priv;
  myPublicKeyArmored  = pub;
  console.log('ğŸ”‘ Chiavi caricate dal file.');
} else {
  const chiavi = await generaChiavi(myUsername, email, myPassphrase);
  myPrivateKeyArmored = chiavi.privateKeyArmored;
  myPublicKeyArmored  = chiavi.publicKeyArmored;
  fs.writeFileSync(CHIAVI_FILE, JSON.stringify({
    priv: myPrivateKeyArmored,
    pub:  myPublicKeyArmored,
  }));
}
```

### Esercizio C â€” Nonce anti-replay con `crypto`

UDP non garantisce l'ordine nÃ© deduplicazione. Aggiungi un nonce casuale con il modulo `crypto` (core) per prevenire replay:

```javascript
const crypto = require('crypto'); // modulo core

// Prima di cifrare, avvolgi il testo con un nonce
const nonce = crypto.randomBytes(16).toString('hex');
const envelope = JSON.stringify({ nonce, testo, ts: Date.now() });
const payload = await cifraEFirma(envelope, pubKeyDest, myPrivateKeyArmored, myPassphrase);

// Alla ricezione, dopo la decifratura
const nonceVisti = new Set();
const { testo: envelope, firmaValida } = await decifraEVerifica(...);
const { nonce, testo, ts } = JSON.parse(envelope);

if (nonceVisti.has(nonce)) {
  stampa('âš ï¸ Datagram replay ignorato');
  return;
}
nonceVisti.add(nonce);
// Visualizza il messaggio
stampa(`  > ${testo}`);
```

### Esercizio D â€” Chunking per messaggi grandi

Per messaggi che superano la soglia sicura (~50 KB), implementa il chunking lato client:

```javascript
const CHUNK_SIZE = 50_000; // byte per chunk

async function inviaGrande(testo) {
  const payload = await cifraEFirma(testo, pubKeyDest, myPrivateKeyArmored, myPassphrase);
  const chunks  = payload.match(new RegExp(`.{1,${CHUNK_SIZE}}`, 'g'));
  const msgId   = Date.now().toString(36);

  for (let i = 0; i < chunks.length; i++) {
    invia({
      type:    'chunk',
      from:    myUsername,
      to:      destinatario,
      msgId,                 // identifica il messaggio
      index:   i,            // indice del chunk
      total:   chunks.length,
      data:    chunks[i],
    });
  }
}

// Lato ricevente: riassembla i chunk prima di decifrare
const chunkBuffer = new Map(); // msgId â†’ { received: [], total }

case 'chunk': {
  const { msgId, index, total, data, from } = frame;
  if (!chunkBuffer.has(msgId)) chunkBuffer.set(msgId, { received: [], total });
  const buf = chunkBuffer.get(msgId);
  buf.received[index] = data;

  if (buf.received.filter(Boolean).length === total) {
    // Tutti i chunk arrivati: riassembla e decifra
    const payloadCompleto = buf.received.join('');
    chunkBuffer.delete(msgId);
    // Decifra come un messaggio normale
    const { testo } = await decifraEVerifica(payloadCompleto, ...);
    stampa(`  > ${testo}`);
  }
  break;
}
```

---

## Confronto con protocolli reali

| Aspetto | Questa implementazione | DTLS | Signal Protocol |
|---------|----------------------|------|-----------------|
| Trasporto | UDP raw | UDP + TLS | TCP + TLS |
| Cifratura contenuto | OpenPGP (ECC) | TLS | Double Ratchet |
| Perfect Forward Secrecy | âŒ No | âœ… SÃ¬ | âœ… SÃ¬ |
| Metadati nascosti | âŒ No | âœ… SÃ¬ | âš ï¸ Parziale |
| Garanzia consegna | âŒ No | âŒ No (UDP) | âœ… SÃ¬ (TCP) |
| Moduli usati | `dgram`, `openpgp` | `dtls` (esterno) | Librerie dedicate |
| Dipendenze esterne | Solo `openpgp` | Molte | Molte |

---

## ğŸ”— Collegamenti

- **Precedente**: [21.03 - Backup E2E](21.03_backup_e2e.md)
- **Indice capitolo**: [21 - Casi d'uso Node.js PGP](21%20casi_d_uso_nodejs_pgp.md)
- **Riferimento teorico**: [Capitolo 21 - PGP/GPG](../21_pgpgpg.md)
- **Base crittografica**: [21.02 - PGP con Node.js](21.02_pgpgpg_nodejs.md)

## ğŸ“š Riferimenti

- Node.js `dgram` module: https://nodejs.org/api/dgram.html
- Node.js `crypto` module: https://nodejs.org/api/crypto.html
- OpenPGP.js API: https://openpgpjs.org/openpgpjs/
- RFC 4880 â€” OpenPGP Message Format: https://www.rfc-editor.org/rfc/rfc4880
- RFC 768 â€” UDP: https://www.rfc-editor.org/rfc/rfc768
