# Cifratura e Firma Digitale con PGP/GPG

PGP (Pretty Good Privacy) e il suo successore open source GPG (GNU Privacy Guard) sono gli strumenti standard per cifrare email, file e comunicazioni in modo End-to-End. In questa guida imparerai come generare una coppia di chiavi, cifrare e decifrare file, e firmare messaggi per garantirne l'autenticità.

## Indice
1. [Introduzione teorica](#introduzione-teorica)
2. [Prerequisiti](#prerequisiti)
3. [Esercitazione Pratica 1](#esercitazione-pratica-1---generazione-e-gestione-delle-chiavi)
4. [Esercitazione Pratica 2](#esercitazione-pratica-2---cifratura-e-decifratura-di-file)
5. [Esercitazione Pratica 3](#esercitazione-pratica-3---firma-digitale-e-verifica)
6. [Esercitazione Pratica 4](#esercitazione-pratica-4---scambio-di-chiavi-con-un-compagno)
7. [Verifica e Troubleshooting](#verifica-e-troubleshooting)
8. [Esercizi](#esercizi)


## Obiettivi della Lezione
- Comprendere il funzionamento della crittografia ibrida di PGP
- Generare una coppia di chiavi GPG (pubblica/privata)
- Cifrare e decifrare file con la chiave pubblica del destinatario
- Firmare digitalmente messaggi e verificarne l'autenticità
- Simulare uno scambio sicuro di messaggi con un compagno di classe

## Introduzione teorica

### Cos'è PGP/GPG?

**PGP (Pretty Good Privacy)** è un sistema di crittografia ideato da Phil Zimmermann nel 1991. **GPG (GNU Privacy Guard)** è l'implementazione libera e open source compatibile con lo standard **OpenPGP (RFC 4880)**.

GPG permette di:
- **Cifrare** file e messaggi in modo che solo il destinatario possa leggerli
- **Firmare digitalmente** documenti per garantirne l'autenticità e l'integrità
- **Verificare** che un file non sia stato alterato e provenga da chi dichiara
- **Gestire** un anello di chiavi di contatti fidati

**Caratteristiche principali:**
- **Crittografia end-to-end**: nessun intermediario può leggere il contenuto
- **Autenticazione**: certifica l'identità del mittente
- **Integrità**: rileva qualsiasi modifica al messaggio
- **Non ripudio**: il mittente non può negare di aver firmato

**Relazione tra PGP, OpenPGP e GPG:**
```
PGP (Phil Zimmermann, 1991 – proprietario)
          ↓
    OpenPGP (RFC 4880 – standard aperto)
          ↓
  GPG / GnuPG (implementazione GNU – gratuita)
```

---

### Crittografia Ibrida

GPG non cifra il messaggio direttamente con la chiave RSA del destinatario (sarebbe troppo lento). Usa invece la **crittografia ibrida**:

#### Processo di Cifratura

```
┌────────────────────────────────────────────────────────┐
│                      MITTENTE                          │
│                                                        │
│  messaggio ──► [AES-256] ──► messaggio cifrato         │
│                   ▲                                    │
│             session key                                │
│                   │                                    │
│             [RSA encrypt] ◄── chiave pubblica          │
│                   │           destinatario             │
│         session key cifrata                            │
└────────────────────────────────────────────────────────┘
                    │ invia: messaggio cifrato +
                    │        session key cifrata
                    ▼
┌────────────────────────────────────────────────────────┐
│                    DESTINATARIO                        │
│                                                        │
│         session key cifrata                            │
│                   │                                    │
│             [RSA decrypt] ◄── chiave privata           │
│                   │           destinatario             │
│             session key                                │
│                   │                                    │
│  messaggio cifrato ──► [AES-256 decrypt] ──► messaggio │
└────────────────────────────────────────────────────────┘
```

**Perché questo modello?**
- **RSA** è sicuro ma lento: usato solo per la breve session key
- **AES** è veloce: usato per cifrare l'intero messaggio
- Ogni messaggio ha una session key diversa e casuale

---

### Firma Digitale

La firma digitale garantisce **autenticità** e **integrità** del messaggio:

```
┌────────────────────────────────────────────────────────┐
│                      MITTENTE                          │
│                                                        │
│  messaggio ──► [SHA-256] ──► hash                      │
│                                │                       │
│                         [RSA sign] ◄── chiave PRIVATA  │
│                                │       del mittente    │
│                            firma                       │
│                                                        │
│  Invia: messaggio + firma                              │
└────────────────────────────────────────────────────────┘
                    │
                    ▼
┌────────────────────────────────────────────────────────┐
│                    DESTINATARIO                        │
│                                                        │
│  messaggio ──► [SHA-256] ──► hash'                     │
│                                                        │
│  firma ──► [RSA verify] ◄── chiave PUBBLICA mittente   │
│                  │                                     │
│                hash                                    │
│                  │                                     │
│         hash == hash' ?                                │
│          ✅ Autentico    ❌ Alterato/Falso              │
└────────────────────────────────────────────────────────┘
```

---

### Web of Trust (WoT)

A differenza di SSL/TLS (che usa una gerarchia di CA), PGP usa un modello **decentralizzato** chiamato **Web of Trust**: ci si fida di una chiave perché qualcuno di già fidato l'ha firmata.

```
         [Alice]  ← ti fidi di lei
        /       \
  firmata       firmata
     /             \
  [Bob]           [Carlo]
     \             /
      firmata    firmata
          \   /
          [Dave]

Se ti fidi di Alice, puoi fidarti (parzialmente) anche di Bob e Carlo
```

**Livelli di fiducia (Trust Level):**

| Livello | Descrizione |
|---------|-------------|
| `unknown` | Non si conosce l'utente |
| `none` | Nessuna fiducia |
| `marginal` | Fiducia parziale |
| `full` | Fiducia completa |
| `ultimate` | Fiducia assoluta (proprie chiavi) |

---

### Tipi di Algoritmi per le Chiavi GPG

| Algoritmo | Tipo | Sicurezza | Velocità | Raccomandato |
|-----------|------|-----------|----------|--------------|
| RSA 2048 | Asimmetrico | Buona | Media | ⚠️ Minimo accettabile |
| RSA 4096 | Asimmetrico | Ottima | Lenta | ✅ Compatibilità |
| DSA | Asimmetrico | Obsoleto | - | ❌ No |
| ElGamal | Asimmetrico | Buona | Media | ⚠️ Solo cifratura |
| Ed25519 (ECC) | Asimmetrico | Eccellente | Velocissima | ✅ Consigliato |
| Cv25519 (ECC) | Asimmetrico | Eccellente | Velocissima | ✅ Consigliato |

**Raccomandazione:** Usare **ECC (Curve25519)** per nuove chiavi, oppure **RSA 4096** per compatibilità con sistemi più vecchi.

---

## Prerequisiti

### Software Necessario

#### Linux
GPG è pre-installato nella maggior parte delle distribuzioni. Verificare con:
```bash
gpg --version
```
Se non presente:
```bash
sudo apt update && sudo apt install gnupg   # Debian/Ubuntu
sudo dnf install gnupg2                     # Fedora/RHEL
```

#### macOS
```bash
brew install gnupg
```

#### Windows
- **Gpg4win**: https://www.gpg4win.org  
  Include GPG, Kleopatra (GUI), GpgOL (integrazione Outlook), GpgEX (menu contestuale)
- **Git Bash**: include una versione di GPG (`gpg --version`)

### Verifica Installazione

```bash
gpg --version
```

Output atteso (esempio):
```
gpg (GnuPG) 2.4.x
libgcrypt 1.10.x
Copyright (C) 2023 g10 Code GmbH
...
Algoritmi supportati:
Chiave pubblica: RSA, ELG, DSA, ECDH, ECDSA, EDDSA
Cifratura simmetrica: IDEA, 3DES, CAST5, BLOWFISH, AES, AES192, AES256, ...
```

---

## Esercitazione Pratica 1 - Generazione e Gestione delle Chiavi

### Step 1: Generare la Coppia di Chiavi

Apri un terminale (Git Bash su Windows, Terminal su Linux/macOS).

#### Opzione A: Chiave ECC Curve25519 (Raccomandato)

```bash
gpg --full-generate-key
```

Scegliere le seguenti opzioni:
```
Selezionare il tipo di chiave:
   (1) RSA e RSA
   (9) ECC (firma e cifratura) *
   ...
Scelta: 9

Selezionare la curva ellittica:
   (1) Curve 25519 *
   ...
Scelta: 1

La chiave non ha scadenza oppure specificare:
   0 = la chiave non scade
   <n> = la chiave scade tra n giorni
   <n>w = la chiave scade tra n settimane
   <n>m = la chiave scade tra n mesi
   <n>y = la chiave scade tra n anni
Scadenza chiave (0)? 1y

Nome reale: Mario Rossi
Indirizzo email: mario.rossi@scuola.it
Commento: [INVIO per lasciare vuoto]

Cambiare (N)ome, (C)ommento, (E)mail o (O)k/(E)sci? O
```

#### Opzione B: Chiave RSA 4096 (Compatibilità)

```bash
gpg --full-generate-key
```

```
Scelta: 1       (RSA e RSA)
Dimensione: 4096
Scadenza: 1y
```

**Parametri:**
- **Tipo chiave**: determina l'algoritmo crittografico
- **Scadenza**: assegnare sempre una scadenza – forza la verifica periodica delle chiavi
- **Nome e Email**: identificano il proprietario della chiave nel keyring
- **Passphrase**: protegge la chiave privata se il file venisse rubato

#### Processo Interattivo – Output Atteso

```
gpg: chiave A1B2C3D4E5F6A7B8 contrassegnata con completa fiducia
gpg: directory '/home/user/.gnupg/openpgp-revocs.d' creata
gpg: certificato di revoca memorizzato come '/home/user/.gnupg/openpgp-revocs.d/...rev'
chiavi pubbliche e private create e firmate.

pub   ed25519 2026-01-01 [SC] [scade: 2027-01-01]
      A1B2C3D4E5F6A7B8C9D0E1F2A3B4C5D6E7F8A9B0
uid                      Mario Rossi <mario.rossi@scuola.it>
sub   cv25519 2026-01-01 [E] [scade: 2027-01-01]
```

✅ **Chiavi generate con successo!**

**Cosa significano i flag:**
- `[SC]` – Sign (firma) e Certify (certifica altre chiavi): chiave principale
- `[E]` – Encrypt (cifratura): sottochiave dedicata alla cifratura
- `pub` – Chiave pubblica principale
- `sub` – Sottochiave (subkey)

---

### Step 2: Verificare le Chiavi Create

#### Visualizzare le chiavi pubbliche (keyring)

```bash
gpg --list-keys
gpg -k    # forma breve
```

Output:
```
/home/user/.gnupg/pubring.kbx
------------------------------
pub   ed25519 2026-01-01 [SC] [scade: 2027-01-01]
      A1B2C3D4E5F6A7B8C9D0E1F2A3B4C5D6E7F8A9B0
uid           [massima] Mario Rossi <mario.rossi@scuola.it>
sub   cv25519 2026-01-01 [E] [scade: 2027-01-01]
```

#### Visualizzare le chiavi private

```bash
gpg --list-secret-keys
gpg -K    # forma breve
```

#### Visualizzare il Fingerprint

Il **fingerprint** è l'impronta digitale univoca della chiave, usata per verificarne l'autenticità:

```bash
gpg --fingerprint mario.rossi@scuola.it
```

Output:
```
pub   ed25519 2026-01-01 [SC] [scade: 2027-01-01]
      A1B2 C3D4 E5F6 A7B8 C9D0  E1F2 A3B4 C5D6 E7F8 A9B0
uid           [massima] Mario Rossi <mario.rossi@scuola.it>
sub   cv25519 2026-01-01 [E] [scade: 2027-01-01]
```

> ⚠️ **Importante**: verifica sempre il fingerprint tramite un canale sicuro (di persona, per telefono) prima di fidarsi di una chiave altrui.

---

### Step 3: Esportare la Chiave Pubblica

La chiave pubblica deve essere condivisa con chi vuole scriverti in modo cifrato o verificare le tue firme.

#### Esportazione in formato ASCII (consigliato per email/testo)

```bash
gpg --armor --export mario.rossi@scuola.it
```

Output:
```
-----BEGIN PGP PUBLIC KEY BLOCK-----

mDMEZ[...]AAAB
[...contenuto codificato base64...]
-----END PGP PUBLIC KEY BLOCK-----
```

#### Esportazione su file

```bash
gpg --armor --export mario.rossi@scuola.it > mario_rossi_pub.asc
```

Verifica che il file sia stato creato:
```bash
cat mario_rossi_pub.asc
ls -la mario_rossi_pub.asc
```

---

### Step 4: Importare la Chiave Pubblica di un Contatto

#### Da file

```bash
gpg --import mario_rossi_pub.asc
```

Output:
```
gpg: key A1B2C3D4: chiave pubblica "Mario Rossi <mario.rossi@scuola.it>" importata
gpg: Numero elaborato: 1
gpg:       importate: 1
```

#### Da un keyserver

```bash
# Cerca per email o ID
gpg --keyserver keys.openpgp.org --search-keys mario.rossi@scuola.it

# Scarica direttamente per ID
gpg --keyserver keys.openpgp.org --recv-keys A1B2C3D4
```

#### Verifica dell'importazione

```bash
gpg --list-keys mario.rossi@scuola.it
```

---

### Step 5: Generare il Certificato di Revoca

> ⚠️ **Farlo subito dopo la creazione della chiave!** Senza questo certificato non potrai invalidare la chiave in caso di compromissione o smarrimento della passphrase.

```bash
gpg --gen-revoke mario.rossi@scuola.it > certificato_revoca.asc
```

```
Si vuole creare un certificato di revoca per questa chiave? (s/N) s
Selezionare il motivo della revoca:
  0 = Nessun motivo specificato
  1 = La chiave è stata compromessa
  2 = La chiave è stata sostituita
  3 = La chiave non è più utilizzata
  Q = Annulla
(Probabilmente si dovrebbe selezionare 1)
Scelta: 0

Inserire una descrizione opzionale; termina con una riga vuota:
> [INVIO]
Motivo della revoca: Nessun motivo specificato
(Nessuna descrizione)
Va bene? (s/N) s
```

```bash
# Conserva il file in modo sicuro
ls -la certificato_revoca.asc
# Salvalo su una chiavetta USB tenuta offline, non lasciarlo sul PC
```

---

## Esercitazione Pratica 2 - Cifratura e Decifratura di File

### Step 1: Cifrare un File per un Destinatario

Per cifrare un file devi avere la **chiave pubblica del destinatario** nel tuo keyring.

#### Cifra un file di testo

Crea prima un file di test:
```bash
echo "Messaggio segreto per Mario Rossi" > messaggio.txt
cat messaggio.txt
```

Cifra il file:
```bash
gpg --encrypt --recipient mario.rossi@scuola.it --armor messaggio.txt
```

**Parametri:**
- `--encrypt`: cifra il file
- `--recipient` (o `-r`): specifica il destinatario (usa la sua chiave pubblica)
- `--armor` (o `-a`): produce output in formato ASCII (`.asc`) invece di binario (`.gpg`)

Output generato: `messaggio.txt.asc`

```bash
cat messaggio.txt.asc
```

```
-----BEGIN PGP MESSAGE-----

hQGMA1234567890...
[contenuto cifrato illeggibile]
-----END PGP MESSAGE-----
```

✅ Il file originale esiste ancora. GPG crea il file cifrato senza cancellare l'originale.

#### Cifra per più destinatari

```bash
gpg --encrypt \
    --recipient mario.rossi@scuola.it \
    --recipient lucia.bianchi@scuola.it \
    --armor \
    messaggio.txt
```

Sia Mario che Lucia potranno decifrare il file con le proprie chiavi private.

#### Salva il file cifrato con un nome specifico

```bash
gpg --output messaggio_cifrato.asc \
    --encrypt \
    --recipient mario.rossi@scuola.it \
    --armor \
    messaggio.txt
```

---

### Step 2: Decifrare un File

GPG rileva automaticamente quale chiave privata usare tra quelle disponibili nel tuo keyring.

```bash
gpg --decrypt messaggio.txt.asc
```

Output (visualizza il contenuto sul terminale):
```
gpg: cifrato con chiave cv25519 A1B2C3D4, creata 2026-01-01
      "Mario Rossi <mario.rossi@scuola.it>"
Messaggio segreto per Mario Rossi
```

#### Salva il contenuto decifrato su file

```bash
gpg --output messaggio_decifrato.txt --decrypt messaggio.txt.asc
cat messaggio_decifrato.txt
```

---

### Step 3: Cifratura Simmetrica (solo passphrase, senza chiavi)

Utile quando non si ha la chiave pubblica del destinatario o per uso personale:

```bash
gpg --symmetric --armor note_private.txt
```

GPG chiede una passphrase. L'output è `note_private.txt.asc`.

Decifra con:
```bash
gpg --decrypt note_private.txt.asc
```

GPG chiederà la stessa passphrase usata per cifrare.

---

## Esercitazione Pratica 3 - Firma Digitale e Verifica

### Step 1: I Tre Modi di Firmare

GPG offre tre modalità di firma a seconda del caso d'uso:

| Comando | Modalità | Output | Uso tipico |
|---------|---------|--------|------------|
| `--clearsign` | Firma in chiaro | messaggio leggibile + firma allegata | Email, testo |
| `--sign` | Firma inclusa | file compresso + firma | File binari |
| `--detach-sign` | Firma separata | file originale + file `.sig` separato | Distribuzione software |

---

### Step 2: Firma in Chiaro (`--clearsign`)

Ideale per messaggi di testo dove il contenuto deve rimanere leggibile anche senza GPG:

```bash
echo "Comunicazione ufficiale: la lezione del 5 marzo è annullata." > comunicato.txt
gpg --clearsign comunicato.txt
```

Output generato: `comunicato.txt.asc`

```bash
cat comunicato.txt.asc
```

```
-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

Comunicazione ufficiale: la lezione del 5 marzo è annullata.
-----BEGIN PGP SIGNATURE-----

iQGzBAABCgAdFiEE[...]
-----END PGP SIGNATURE-----
```

✅ Il testo è leggibile anche da chi non usa GPG. La firma è allegata in fondo.

---

### Step 3: Firma Separata (`--detach-sign`)

Utile per distribuire un file mantenendo separata la firma (es. software, PDF):

```bash
gpg --detach-sign --armor relazione.pdf
```

Produce: `relazione.pdf.asc` (contiene solo la firma, non il file)

Distribuisci entrambi i file: `relazione.pdf` + `relazione.pdf.asc`

---

### Step 4: Verificare una Firma

#### Verifica di firma in chiaro

```bash
gpg --verify comunicato.txt.asc
```

Output quando la firma è **valida**:
```
gpg: Firma fatta il mer  1 gen 2026 10:00:00 CET
gpg:                usando la chiave ED25519 A1B2C3D4E5F6A7B8C9D0...
gpg: Firma valida di "Mario Rossi <mario.rossi@scuola.it>" [piena]
```

Output quando la firma è **non valida** (file modificato):
```
gpg: Firma fatta il mer  1 gen 2026 10:00:00 CET
gpg:                usando la chiave ED25519 A1B2C3D4E5F6A7B8C9D0...
gpg: FIRMA NON VALIDA di "Mario Rossi <mario.rossi@scuola.it>" [sconosciuta]
```

#### Verifica di firma separata

```bash
gpg --verify relazione.pdf.asc relazione.pdf
```

---

### Step 5: Cifrare E Firmare Insieme

Nella pratica quotidiana si cifra e si firma nello stesso momento: il destinatario riceve un messaggio cifrato e può verificare che sei stato tu a inviarlo.

```bash
gpg --encrypt --sign \
    --recipient mario.rossi@scuola.it \
    --armor \
    documento.txt
```

GPG chiederà la passphrase della tua chiave privata per la firma.

---

## Esercitazione Pratica 4 - Scambio di Chiavi con un Compagno

Questa esercitazione simula uno scenario reale: due persone si scambiano messaggi cifrati e firmati.

### Scenario

**Studente A** (tu) vuole inviare un messaggio cifrato allo **Studente B** (il tuo compagno).

---

### Parte 1: Scambio delle Chiavi Pubbliche

#### Studente A: esporta la propria chiave pubblica

```bash
gpg --armor --export tua.email@scuola.it > chiave_pub_studenteA.asc
```

#### Studente B: esporta la propria chiave pubblica

```bash
gpg --armor --export sua.email@scuola.it > chiave_pub_studenteB.asc
```

#### Scambia i file

Trasferisci il file via:
- USB, email, chat, server condiviso – non importa: la chiave **pubblica** non è segreta

#### Importa la chiave del compagno

**Studente A** importa la chiave di **Studente B**:
```bash
gpg --import chiave_pub_studenteB.asc
```

**Studente B** importa la chiave di **Studente A**:
```bash
gpg --import chiave_pub_studenteA.asc
```

---

### Parte 2: Verifica del Fingerprint

> ⚠️ **Questo passaggio è fondamentale!** Senza verifica, potremmo essere vittima di un attacco man-in-the-middle.

Confrontate il fingerprint **di persona o per telefono** (non via chat o email, potrebbero essere compromessi):

**Studente A** mostra il fingerprint della sua chiave:
```bash
gpg --fingerprint tua.email@scuola.it
```

**Studente B** verifica che la chiave importata abbia lo stesso fingerprint:
```bash
gpg --fingerprint tua.email@scuola.it
```

Se corrispondono ✅ → la chiave è autentica, non è stata manomessa.

---

### Parte 3: Impostare il Livello di Fiducia

Dopo aver verificato il fingerprint, imposta la fiducia nella chiave del compagno:

```bash
gpg --edit-key sua.email@scuola.it
```

```
gpg> trust
```

```
Decidi quanto ti fidi di questo utente per certificare le chiavi degli altri utenti
  1 = Non so o preferisco non rispondere
  2 = NON mi fido
  3 = Mi fido marginalmente
  4 = Mi fido completamente
  5 = Mi fido in modo assoluto
  m = torna al menu principale
Decisione? 4
```

```
gpg> quit
```

---

### Parte 4: Invio del Messaggio Cifrato e Firmato

**Studente A** crea e invia un messaggio a **Studente B**:

```bash
# Crea il messaggio
echo "Ciao! Questo messaggio è stato cifrato e firmato da Mario Rossi." > msg_per_B.txt

# Cifra e firma
gpg --encrypt --sign \
    --recipient sua.email@scuola.it \
    --armor \
    msg_per_B.txt
```

Output: `msg_per_B.txt.asc`

Invia il file `.asc` allo **Studente B** (via USB, email, server).

---

### Parte 5: Ricezione e Verifica

**Studente B** riceve il file, lo decifra e verifica la firma:

```bash
gpg --decrypt msg_per_B.txt.asc
```

Output atteso:
```
gpg: cifrato con chiave cv25519 [ID], creata 2026-01-01
      "Lucia Bianchi <lucia.bianchi@scuola.it>"
gpg: Firma fatta il [data e ora]
gpg:                usando la chiave ED25519 [ID]
gpg: Firma valida di "Mario Rossi <mario.rossi@scuola.it>" [piena]
Ciao! Questo messaggio è stato cifrato e firmato da Mario Rossi.
```

✅ Due informazioni in un'unica operazione:
1. Solo Lucia può leggere il messaggio (cifratura)
2. Mario ha certamente inviato il messaggio e non è stato alterato (firma)

---

## Approfondimenti sulla Sicurezza GPG

### Struttura dei File GPG

```bash
~/.gnupg/
├── pubring.kbx              # Keyring chiavi pubbliche
├── trustdb.gpg              # Database fiducia
├── private-keys-v1.d/       # Chiavi private (NEVER share!)
│   └── [ID].key
└── openpgp-revocs.d/        # Certificati di revoca
    └── [FINGERPRINT].rev
```

### Permessi Corretti

```bash
# Imposta i permessi corretti (fondamentale!)
chmod 700 ~/.gnupg
chmod 600 ~/.gnupg/private-keys-v1.d/*
chmod 600 ~/.gnupg/*.gpg
chmod 600 ~/.gnupg/*.kbx
```

### Backup delle Chiavi

> ⚠️ Senza backup perdi per sempre la tua chiave privata e non potrai decifrare i messaggi ricevuti in precedenza.

```bash
# Esporta chiave privata (conserva in luogo sicuro e offline)
gpg --armor --export-secret-keys tua.email@scuola.it > backup_privata.asc

# Esporta anche la fiducia
gpg --export-ownertrust > backup_trust.txt

# Ripristina su un altro sistema
gpg --import backup_privata.asc
gpg --import-ownertrust backup_trust.txt
```

### Revocare una Chiave

Se la chiave è stata compromessa o persa, pubblica il certificato di revoca:

```bash
# Importa il certificato di revoca
gpg --import certificato_revoca.asc

# Pubblica la revoca sul keyserver
gpg --keyserver keys.openpgp.org --send-keys FINGERPRINT
```

Da questo momento chiunque aggiorni il keyring vedrà la chiave come revocata.

### Pubblicare la Propria Chiave su Keyserver

```bash
# Pubblica su keys.openpgp.org (GDPR-compliant)
gpg --keyserver keys.openpgp.org --send-keys tua.email@scuola.it

# Recupera la chiave di qualcuno dal keyserver
gpg --keyserver keys.openpgp.org --search-keys mario.rossi@scuola.it
```

---

## Verifica e Troubleshooting

### Verificare la Connessione in Modalità Verbose

```bash
gpg --verbose --decrypt messaggio.txt.asc
```

### Problemi Comuni

#### 1. "No public key" durante la cifratura

**Causa**: la chiave pubblica del destinatario non è nel keyring.

**Soluzione:**
```bash
# Verifica le chiavi presenti
gpg --list-keys

# Importa la chiave mancante
gpg --import chiave_destinatario.asc

# Oppure cercala su keyserver
gpg --keyserver keys.openpgp.org --search-keys email@dominio.it
```

#### 2. "No secret key" durante la decifratura

**Causa**: il messaggio è stato cifrato per una chiave diversa, oppure la chiave privata non è presente sul sistema.

**Soluzione:**
```bash
# Verifica le chiavi private disponibili
gpg --list-secret-keys

# Se hai un backup, importa la chiave privata
gpg --import backup_privata.asc
```

#### 3. "Bad passphrase"

**Causa**: la passphrase inserita non è corretta.

**Soluzione:**
```bash
# Non è possibile recuperare la passphrase dimenticata.
# Se hai il backup della chiave, reimporta e imposta una nuova passphrase:
gpg --edit-key tua.email@scuola.it
# gpg> passwd
# Inserisci la vecchia passphrase, poi la nuova
# gpg> save
```

#### 4. "WARNING: This key is not certified with a trusted signature!"

**Causa**: la chiave non è stata firmata da qualcuno di cui ti fidi (Web of Trust).

**Soluzione:** Questo è un avviso, non un errore bloccante. Imposta la fiducia:
```bash
gpg --edit-key email@dominio.it
# gpg> trust
# Scegli il livello (3 = marginale, 4 = completa)
# gpg> quit
```

#### 5. "gpg: decryption failed: No secret key"

**Causa**: il messaggio è cifrato per una chiave che non possiedi.

**Verifica:**
```bash
# Mostra per quale chiave è cifrato il messaggio
gpg --list-packets messaggio.txt.asc | grep "keyid"
```

---

### Comandi Utili per Diagnostica

```bash
# Lista tutte le chiavi pubbliche
gpg --list-keys

# Lista tutte le chiavi private
gpg --list-secret-keys

# Mostra fingerprint di tutte le chiavi
gpg --fingerprint

# Mostra informazioni dettagliate su un messaggio cifrato
gpg --list-packets messaggio.txt.asc

# Verifica la validità di una firma senza decifrare
gpg --verify documento.asc

# Prova a decifrare con output verbose
gpg --verbose --decrypt messaggio.txt.asc
```

---

## Esercizi

### Esercizio 1: Generazione e Ispezione Chiavi (★☆☆)

1. Genera una coppia di chiavi GPG con algoritmo ECC (Curve25519) e scadenza 1 anno
2. Visualizza la chiave nel keyring con `--list-keys` e identifica il fingerprint
3. Esporta la chiave pubblica in formato ASCII su file
4. Genera il certificato di revoca e conservalo in una cartella sicura

**Domande:**
- Cosa significa il flag `[SC]` accanto alla chiave principale e `[E]` accanto alla sottochiave?
- Perché è importante impostare una scadenza?

### Esercizio 2: Cifratura Base (★★☆)

1. Crea un file di testo con il tuo nome, cognome e un messaggio a piacere
2. Cifra il file con la tua stessa chiave pubblica (`--recipient tua.email`)
3. Verifica che il file cifrato sia illeggibile con un editor di testo
4. Decifra il file e verifica che il contenuto corrisponda all'originale
5. Prova a modificare il file `.asc` con un editor e tenta di decifrarlo: cosa succede?

**Domande:**
- Perché è possibile cifrare un messaggio per se stessi?
- Cosa succede se si tenta di decifrare un file modificato?

### Esercizio 3: Firma Digitale (★★☆)

1. Crea un documento di testo con `--clearsign`
2. Apri il file `.asc` con un editor: il testo è leggibile?
3. Verifica la firma con `--verify`
4. Modifica una singola lettera del testo firmato e tenta nuovamente la verifica: cosa riporta GPG?
5. Ripeti con `--detach-sign`: quali file vengono generati?

**Domande:**
- Qual è la differenza tra `--sign`, `--clearsign` e `--detach-sign`?
- La firma garantisce la confidenzialità del messaggio?

### Esercizio 4: Scambio con un Compagno (★★★)

1. Scambia la chiave pubblica con un compagno (via USB o server)
2. Prima di importarla, verifica il fingerprint di persona
3. Imposta il livello di fiducia appropriato dopo la verifica
4. Inviagli un messaggio cifrato e firmato
5. Ricevi il suo messaggio, decifra e verifica la firma
6. Prova anche a cifrarti il messaggio per te stesso oltre che per il compagno (multi-recipient)

**Domande:**
- Perché è fondamentale verificare il fingerprint di persona?
- Come si differenzia il modello Web of Trust da PKI con CA?

### Esercizio 5: Sicurezza e Revoca (★★★)

1. Importa il certificato di revoca della tua chiave
2. Lista di nuovo le chiavi: come appare la chiave revocata?
3. Rimuovi la chiave revocata dal keyring con `gpg --delete-key`
4. Rigenera la coppia di chiavi e crea un nuovo certificato di revoca
5. Prova a decifrare un file cifrato in precedenza con la chiave revocata: cosa succede?

**Domande:**
- Cosa determina la differenza tra una chiave revocata e una scaduta?
- Cosa succede ai messaggi già cifrati con una chiave revocata?

---

## Riferimenti e Approfondimenti

### Documentazione Ufficiale
- [GnuPG Official Documentation](https://www.gnupg.org/documentation/)
- [OpenPGP Standard – RFC 4880](https://datatracker.ietf.org/doc/html/rfc4880)

### Best Practices di Sicurezza
- Usa sempre una passphrase per proteggere la chiave privata
- Non condividere mai la chiave privata – neanche con il professore!
- Genera il certificato di revoca subito e conservalo offline
- Verifica sempre il fingerprint di persona prima di fidarti di una chiave
- Imposta una scadenza e rinnova la chiave periodicamente
- Fai un backup cifrato della chiave privata

### Comandi di Riferimento Rapido

```bash
# Generazione chiavi
gpg --full-generate-key

# Listare chiavi
gpg --list-keys
gpg --list-secret-keys
gpg --fingerprint email@dominio.it

# Esportare / Importare
gpg --armor --export email@dominio.it > chiave.asc
gpg --import chiave.asc

# Keyserver
gpg --keyserver keys.openpgp.org --send-keys FINGERPRINT
gpg --keyserver keys.openpgp.org --recv-keys FINGERPRINT

# Cifratura
gpg --encrypt --recipient email@dominio.it --armor file.txt
gpg --decrypt file.txt.asc
gpg --output decifrato.txt --decrypt file.txt.asc

# Firma
gpg --clearsign file.txt            # firma + testo leggibile
gpg --sign file.txt                 # firma + testo compresso
gpg --detach-sign --armor file.txt  # firma separata
gpg --verify file.txt.asc           # verifica firma

# Backup
gpg --armor --export-secret-keys email@dominio.it > privata.asc
gpg --export-ownertrust > trust.txt
gpg --import privata.asc
gpg --import-ownertrust trust.txt

# Revoca
gpg --gen-revoke email@dominio.it > revoca.asc
gpg --import revoca.asc

# Fiducia
gpg --edit-key email@dominio.it
# gpg> trust → salva livello
# gpg> sign  → firma la chiave
# gpg> quit
```

---

## Conclusioni

Hai imparato a:
✅ Comprendere la crittografia ibrida di PGP  
✅ Generare e gestire coppie di chiavi GPG  
✅ Cifrare file per uno o più destinatari  
✅ Firmare digitalmente documenti e verificarne l'autenticità  
✅ Simulare uno scambio sicuro di messaggi con verifica del fingerprint  
✅ Gestire il ciclo di vita delle chiavi (scadenza, backup, revoca)  

GPG è uno strumento fondamentale nella cassetta degli attrezzi di chi lavora con la sicurezza informatica. Pratica lo scambio di chiavi con i tuoi compagni e ricorda: la sicurezza di PGP dipende dalla corretta verifica del fingerprint!

---

**Autore**: Prof. Filippo Bilardo  
**Corso**: Sistemi e Reti 3  
**Data**: Febbraio 2026
