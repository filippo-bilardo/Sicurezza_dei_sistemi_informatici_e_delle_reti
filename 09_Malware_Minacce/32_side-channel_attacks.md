# Capitolo 32 - Side-Channel Attacks

> **Corso**: Sistemi e Reti 3  
> **Parte**: 9 - Malware e Minacce  
> **Autore**: Prof. Filippo Bilardo

---

## Introduzione

I **Side-Channel Attacks** (attacchi a canale laterale) sono tecniche che sfruttano informazioni fisiche involontariamente emesse da un sistema durante l'esecuzione di operazioni crittografiche o di elaborazione.

Invece di attaccare direttamente l'algoritmo matematico, questi attacchi analizzano:
- **Consumo energetico**
- **Emissioni elettromagnetiche**
- **Tempo di esecuzione**
- **Suoni emessi**
- **Calore generato**

### Obiettivi di Apprendimento
- Comprendere i principi dei side-channel attacks
- Analizzare diverse tipologie di attacchi a canale laterale
- Implementare contromisure efficaci
- Valutare vulnerabilit√† side-channel in sistemi reali

---

## Concetti Fondamentali

### Perch√© Funzionano?

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  IMPLEMENTAZIONE CRITTOGRAFIA         ‚îÇ
‚îÇ                                       ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ  Algoritmo Matematico          ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  (AES, RSA, ECC)               ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  Teoricamente Sicuro ‚úì         ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ              ‚Üì                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ  Implementazione Fisica        ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Transistor                  ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Circuiti                    ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ  - Istruzioni CPU              ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ              ‚Üì                        ‚îÇ
‚îÇ       Emissioni Fisiche               ‚îÇ
‚îÇ       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ       ‚îÇTempo‚îÇPower‚îÇ EM  ‚îÇAudio‚îÇ       ‚îÇ
‚îÇ       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
‚îÇ              ‚Üë                        ‚îÇ
‚îÇ         ATTACCANTE                    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Modello di Attacco

1. **Accesso fisico**: spesso necessario (ma non sempre)
2. **Misurazione**: raccolta dati side-channel
3. **Analisi statistica**: correlazione con operazioni crittografiche
4. **Estrazione chiave**: recupero informazioni segrete

---

## 1. Timing Attacks

### Principio

Le operazioni crittografiche richiedono **tempo variabile** in base ai dati elaborati.

### Esempio: RSA Timing Attack

```python
import time

def modular_exponentiation_vulnerable(base, exponent, modulus):
    """
    Implementazione VULNERABILE di modular exponentiation
    Tempo dipende dal numero di bit '1' nell'esponente
    """
    result = 1
    base = base % modulus
    
    while exponent > 0:
        if exponent & 1:  # Se bit corrente √® 1
            result = (result * base) % modulus  # ‚Üê Operazione LENTA
        exponent >>= 1
        base = (base * base) % modulus
    
    return result

def rsa_decrypt_vulnerable(ciphertext, d, n):
    """Decifrazione RSA vulnerabile a timing attack"""
    start = time.perf_counter()
    plaintext = modular_exponentiation_vulnerable(ciphertext, d, n)
    elapsed = time.perf_counter() - start
    
    return plaintext, elapsed

# Attacco timing
def timing_attack_demo():
    """Dimostra timing attack su RSA"""
    
    # Parametri RSA (piccoli per demo)
    p, q = 61, 53
    n = p * q  # 3233
    phi = (p-1) * (q-1)
    e = 17
    d = 2753  # Chiave privata da scoprire!
    
    # Collezione timing
    timings = []
    ciphertexts = range(100, 200)
    
    for c in ciphertexts:
        _, t = rsa_decrypt_vulnerable(c, d, n)
        timings.append((c, t))
    
    # Analisi correlazione tempo/operazioni
    timings.sort(key=lambda x: x[1])
    
    print("Ciphertext pi√π veloci (pochi bit '1' in d):")
    for c, t in timings[:5]:
        print(f"  C={c}: {t*1e6:.2f} Œºs")
    
    print("\nCiphertext pi√π lenti (molti bit '1' in d):")
    for c, t in timings[-5:]:
        print(f"  C={c}: {t*1e6:.2f} Œºs")

# timing_attack_demo()
```

### Caso Reale: Lucky Thirteen (TLS)

Attacco timing su padding CBC in TLS:

```python
def verify_padding_vulnerable(plaintext):
    """
    Verifica padding PKCS#7 vulnerabile
    Tempo dipende da dove si trova errore padding
    """
    import time
    
    padding_length = plaintext[-1]
    
    # VULNERABILE: esce al primo errore
    for i in range(padding_length):
        if plaintext[-(i+1)] != padding_length:
            return False  # ‚Üê Tempo variabile!
        time.sleep(0.000001)  # Simula elaborazione
    
    return True

def verify_padding_secure(plaintext):
    """
    Verifica padding TEMPO COSTANTE
    Controlla sempre tutti i byte
    """
    padding_length = plaintext[-1]
    valid = True
    
    # Controlla sempre TUTTI i byte (constant-time)
    for i in range(len(plaintext)):
        if i >= len(plaintext) - padding_length:
            if plaintext[i] != padding_length:
                valid = False  # Non esce subito!
    
    return valid

# Test differenza
import time

data_valid = b"Hello World!" + bytes([4, 4, 4, 4])
data_invalid = b"Hello World!" + bytes([4, 4, 4, 3])

# Vulnerabile
start = time.perf_counter()
verify_padding_vulnerable(data_valid)
t1 = time.perf_counter() - start

start = time.perf_counter()
verify_padding_vulnerable(data_invalid)
t2 = time.perf_counter() - start

print(f"Timing differenza: {abs(t1-t2)*1e6:.2f} Œºs")
```

### Contromisure Timing

```python
import hmac
import hashlib

def constant_time_compare(a, b):
    """Confronto stringe a tempo costante"""
    if len(a) != len(b):
        return False
    
    result = 0
    for x, y in zip(a, b):
        result |= x ^ y  # XOR, sempre eseguito
    
    return result == 0

# Usare libreria standard
hmac.compare_digest(b"secret1", b"secret2")  # Tempo costante

def modular_exp_constant_time(base, exp, mod):
    """Modular exponentiation a tempo costante"""
    result = 1
    base = base % mod
    
    # Sempre esegue moltiplicazione, ignora risultato se bit=0
    for i in range(exp.bit_length()):
        bit = (exp >> i) & 1
        
        # Dummy operation se bit=0
        temp = (result * base) % mod
        result = result if bit == 0 else temp
        
        base = (base * base) % mod
    
    return result
```

---

## 2. Power Analysis Attacks

### Simple Power Analysis (SPA)

Analizza **singola** traccia consumo energetico.

```python
import numpy as np
import matplotlib.pyplot as plt

def simulate_power_consumption(key_bit):
    """
    Simula consumo energetico durante operazione crittografica
    bit=1: consumo alto, bit=0: consumo basso
    """
    baseline = 5.0  # mW
    
    if key_bit == 1:
        # Operazione moltiplicazione (pi√π transistor attivi)
        return baseline + np.random.normal(2.0, 0.3)
    else:
        # Solo shift (meno transistor attivi)
        return baseline + np.random.normal(0.5, 0.2)

def spa_attack_demo():
    """Dimostra Simple Power Analysis"""
    
    # Chiave segreta (8-bit per semplicit√†)
    secret_key = 0b10110011  # 179 in decimale
    
    # Simula esecuzione modular exponentiation
    power_trace = []
    
    for i in range(8):
        bit = (secret_key >> i) & 1
        power = simulate_power_consumption(bit)
        power_trace.append(power)
    
    # Visualizza
    plt.figure(figsize=(12, 4))
    plt.plot(power_trace, marker='o', linewidth=2, markersize=8)
    plt.axhline(y=6.5, color='r', linestyle='--', label='Soglia')
    plt.xlabel('Bit Position')
    plt.ylabel('Power Consumption (mW)')
    plt.title('SPA: Power Trace Reveals Secret Key')
    plt.legend()
    plt.grid(True)
    
    # Estrai chiave
    recovered_key = 0
    for i, power in enumerate(power_trace):
        if power > 6.5:  # Soglia
            recovered_key |= (1 << i)
    
    print(f"Chiave originale: {secret_key:08b} ({secret_key})")
    print(f"Chiave recuperata: {recovered_key:08b} ({recovered_key})")
    print(f"Attacco riuscito: {secret_key == recovered_key}")
    
    # plt.savefig('spa_attack.png')
    # plt.show()

spa_attack_demo()
```

### Differential Power Analysis (DPA)

Analizza **multiple** tracce con analisi statistica.

```python
import numpy as np
from scipy import stats

def aes_sbox(byte):
    """AES S-Box semplificata (per demo)"""
    # In AES reale: lookup table 256 elementi
    return byte ^ 0x63  # Semplificazione

def hamming_weight(byte):
    """Calcola Hamming Weight (numero di bit '1')"""
    return bin(byte).count('1')

def simulate_aes_power(plaintext, key_byte):
    """Simula consumo durante operazione AES"""
    
    # SubBytes: plaintext XOR key ‚Üí S-Box
    intermediate = aes_sbox(plaintext ^ key_byte)
    
    # Consumo proporzionale a Hamming Weight
    hw = hamming_weight(intermediate)
    
    # Aggiungi rumore
    noise = np.random.normal(0, 1.5)
    power = 5.0 + 0.3 * hw + noise
    
    return power, hw

def dpa_attack():
    """Differential Power Analysis su byte chiave AES"""
    
    real_key_byte = 0x2B  # Chiave da scoprire (1 byte)
    
    # Raccolta tracce
    num_traces = 1000
    plaintexts = np.random.randint(0, 256, num_traces)
    power_traces = []
    
    print("Raccolta tracce...")
    for pt in plaintexts:
        power, _ = simulate_aes_power(pt, real_key_byte)
        power_traces.append(power)
    
    # Attacco: prova tutte le 256 chiavi possibili
    correlations = []
    
    print("Analisi correlazione...")
    for guess_key in range(256):
        # Ipotesi: calcola HW previsto per ogni traccia
        hypothetical_hw = []
        for pt in plaintexts:
            intermediate = aes_sbox(pt ^ guess_key)
            hw = hamming_weight(intermediate)
            hypothetical_hw.append(hw)
        
        # Correlazione tra HW ipotetico e consumo reale
        corr, _ = stats.pearsonr(hypothetical_hw, power_traces)
        correlations.append(abs(corr))
    
    # Chiave con correlazione massima
    found_key = np.argmax(correlations)
    max_corr = correlations[found_key]
    
    print(f"\n{'='*50}")
    print(f"Chiave reale:     0x{real_key_byte:02X} ({real_key_byte})")
    print(f"Chiave trovata:   0x{found_key:02X} ({found_key})")
    print(f"Correlazione:     {max_corr:.4f}")
    print(f"Attacco riuscito: {real_key_byte == found_key}")
    
    # Top 5 candidati
    top5 = np.argsort(correlations)[-5:][::-1]
    print(f"\nTop 5 candidati:")
    for i, k in enumerate(top5, 1):
        print(f"  {i}. 0x{k:02X}: corr={correlations[k]:.4f}")

dpa_attack()
```

### Contromisure Power Analysis

```python
def masked_aes_sbox(plaintext, key, mask):
    """
    AES S-Box con masking (contromisura DPA)
    Maschera nasconde valore intermedio reale
    """
    
    # Operazione mascherata
    masked_input = plaintext ^ key ^ mask
    masked_output = aes_sbox(masked_input)
    
    # Rimuovi maschera (fuori da side-channel critico)
    output = masked_output ^ aes_sbox(mask)
    
    return output

# Altre contromisure:
# 1. Random delays
import time
import random

def protected_operation(data):
    time.sleep(random.uniform(0, 0.001))  # Delay random
    # Operazione crittografica
    pass

# 2. Noise generation
def add_noise():
    """Genera operazioni dummy per mascherare consumo"""
    dummy = sum(range(random.randint(100, 1000)))

# 3. Constant-power operations
# Hardware: balanced gates, dual-rail logic
```

---

## 3. Electromagnetic (EM) Attacks

### Principio

Dispositivi elettronici emettono **radiazioni elettromagnetiche** correlate all'attivit√† interna.

### Setup Attacco EM

```python
import numpy as np
import scipy.signal as signal

def simulate_em_emission(cpu_activity):
    """
    Simula emissioni EM durante elaborazione
    """
    # Frequenza portante (clock CPU)
    freq_carrier = 2.4e9  # 2.4 GHz
    
    # Modulazione basata su attivit√†
    time_samples = np.linspace(0, 1e-6, 1000)  # 1 microsecondo
    
    # Segnale carrier
    carrier = np.sin(2 * np.pi * freq_carrier * time_samples)
    
    # Modulazione da attivit√† CPU
    modulation = 1 + 0.2 * cpu_activity
    
    # EM emission
    em_signal = carrier * modulation
    
    # Aggiungi rumore ambientale
    noise = np.random.normal(0, 0.1, len(em_signal))
    
    return em_signal + noise

def em_attack_aes():
    """Attacco EM su implementazione AES"""
    
    print("Attacco Elettromagnetico su AES")
    print("="*50)
    
    # Simula AES round
    key_byte = 0xAB
    plaintext = 0x42
    
    # Operazione AES
    intermediate = aes_sbox(plaintext ^ key_byte)
    
    # Simula EM durante clock cycles
    em_traces = []
    for clock in range(16):  # 16 clock cycles
        if clock == 5:  # SubBytes avviene al clock 5
            activity = hamming_weight(intermediate) / 8.0
        else:
            activity = 0.5  # Attivit√† base
        
        em = simulate_em_emission(activity)
        em_traces.append(np.mean(em))
    
    # Analizza picchi
    peaks, _ = signal.find_peaks(em_traces, height=0.6)
    
    print(f"Plaintext: 0x{plaintext:02X}")
    print(f"Key byte:  0x{key_byte:02X}")
    print(f"Picchi EM rilevati a clock cycles: {peaks}")
    
    return em_traces

# em_traces = em_attack_aes()
```

### Caso Reale: TEMPEST

**TEMPEST** = standard NSA per protezione contro EM emanations.

```python
def tempest_keyboard_eavesdropping():
    """
    Simulazione intercettazione tastiera via EM
    Ogni tasto ha firma EM unica
    """
    
    # Database firme EM tasti
    key_signatures = {
        'a': [0.2, 0.5, 0.3, 0.1],
        'b': [0.3, 0.4, 0.4, 0.2],
        's': [0.4, 0.6, 0.2, 0.15],
        # ... altri tasti
    }
    
    def capture_em_from_keyboard():
        """Cattura emissioni da tastiera"""
        # Simula: in realt√† serve antenna SDR
        captured = [0.2, 0.5, 0.3, 0.1]  # Pattern catturato
        return captured
    
    def match_signature(captured):
        """Trova corrispondenza migliore"""
        min_distance = float('inf')
        best_match = None
        
        for key, signature in key_signatures.items():
            # Distanza euclidea
            distance = np.linalg.norm(
                np.array(captured) - np.array(signature)
            )
            if distance < min_distance:
                min_distance = distance
                best_match = key
        
        return best_match
    
    # Attacco
    em_signal = capture_em_from_keyboard()
    pressed_key = match_signature(em_signal)
    
    print(f"EM intercepted: {em_signal}")
    print(f"Key pressed: '{pressed_key}'")

# tempest_keyboard_eavesdropping()
```

### Contromisure EM

```bash
# 1. Schermatura Faraday
# Gabbia metallica attorno a dispositivo

# 2. Zone Controllo Emissioni (TEMPEST-certified rooms)
# Pareti con rete metallica
# Filtri su linee alimentazione

# 3. Distanza sicura
# EM decade con quadrato distanza
# > 20 metri spesso sufficiente per dispositivi consumer

# 4. Frequency hopping
# Cambia frequenza operativa randomicamente

# 5. Noise injection hardware
# Genera EM noise per mascherare segnale utile
```

---

## 4. Acoustic Cryptanalysis

### Principio

Componenti elettronici emettono **suoni** durante elaborazione.

### RSA Key Extraction via Acoustic

```python
import numpy as np
import scipy.fft

def simulate_cpu_acoustic(operation_type):
    """
    Simula suono emesso da CPU durante operazioni
    """
    duration = 0.01  # 10 ms
    sample_rate = 44100  # Hz
    t = np.linspace(0, duration, int(sample_rate * duration))
    
    if operation_type == 'multiply':
        # Moltiplicazione: frequenza alta
        freq = 4500  # Hz
        amplitude = 0.3
    elif operation_type == 'square':
        # Elevamento a quadrato: frequenza media
        freq = 3500
        amplitude = 0.2
    else:
        # Idle
        freq = 2000
        amplitude = 0.1
    
    # Genera tono
    signal = amplitude * np.sin(2 * np.pi * freq * t)
    
    # Aggiungi rumore
    noise = np.random.normal(0, 0.05, len(signal))
    
    return signal + noise

def acoustic_attack_rsa():
    """
    Attacco acustico su RSA
    Basato su: https://www.cs.tau.ac.il/~tromer/acoustic/
    """
    
    print("Acoustic Cryptanalysis - RSA Key Extraction")
    print("="*50)
    
    # Chiave RSA (semplificata)
    secret_exponent = 0b10110011  # 8 bit
    
    # Registra audio durante decifrazione
    audio_trace = []
    
    for i in range(8):
        bit = (secret_exponent >> i) & 1
        
        if bit == 1:
            # Multiply operation
            sound = simulate_cpu_acoustic('multiply')
        else:
            # Square only
            sound = simulate_cpu_acoustic('square')
        
        # Media energia frame audio
        energy = np.mean(np.abs(sound))
        audio_trace.append(energy)
    
    # Analisi spettro
    threshold = np.mean(audio_trace)
    
    recovered_key = 0
    for i, energy in enumerate(audio_trace):
        if energy > threshold:
            recovered_key |= (1 << i)
            print(f"Bit {i}: HIGH energy ({energy:.3f}) ‚Üí 1")
        else:
            print(f"Bit {i}: LOW energy ({energy:.3f})  ‚Üí 0")
    
    print(f"\nChiave originale:  {secret_exponent:08b}")
    print(f"Chiave recuperata: {recovered_key:08b}")
    print(f"Successo: {secret_exponent == recovered_key}")

acoustic_attack_rsa()
```

### Caso Reale: Hard Drive Acoustic

```python
def hdd_acoustic_analysis():
    """
    Analisi pattern accesso disco da suono testina
    Pu√≤ rivelare file acceduti
    """
    
    # Frequenze caratteristiche seek time
    seek_patterns = {
        'short_seek': 800,   # Hz - file piccoli/adiacenti
        'long_seek': 400,    # Hz - file lontani
        'spin_up': 120       # Hz - avvio disco
    }
    
    def analyze_hdd_sound(audio_samples):
        """Analizza audio per identificare operazioni"""
        
        # FFT
        fft = scipy.fft.fft(audio_samples)
        freqs = scipy.fft.fftfreq(len(audio_samples), 1/44100)
        
        # Trova picchi
        magnitude = np.abs(fft)
        peak_freq = freqs[np.argmax(magnitude[:len(freqs)//2])]
        
        # Classifica operazione
        for operation, freq in seek_patterns.items():
            if abs(peak_freq - freq) < 50:
                return operation
        
        return 'unknown'
    
    # Simula
    test_audio = np.sin(2 * np.pi * 800 * np.linspace(0, 0.1, 4410))
    operation = analyze_hdd_sound(test_audio)
    print(f"Operazione rilevata: {operation}")

# hdd_acoustic_analysis()
```

### Contromisure Acoustic

```bash
# 1. Isolamento acustico
# Case insonorizzato
# Materiali fonoassorbenti

# 2. Rumore bianco
# Speaker emette rumore per mascherare suoni CPU

# 3. Utilizzare SSD
# Nessuna parte meccanica ‚Üí meno emissioni acustiche

# 4. Constant-time algorithms
# Stesso suono indipendentemente da chiave
```

---

## 5. Cache Timing Attacks

### Principio

**Cache CPU** ha tempo accesso diverso da RAM principale:
- Cache hit: ~4 cicli clock (~1 ns)
- Cache miss: ~200 cicli clock (~50 ns)

### Flush+Reload Attack

```python
import time
import ctypes

class CacheAttack:
    """Attacco cache Flush+Reload"""
    
    def __init__(self):
        self.threshold = self.calibrate_threshold()
    
    def calibrate_threshold(self):
        """Calibra soglia cache hit/miss"""
        
        # Alloca array
        arr = bytearray(4096)
        
        # Misura cache hit
        hits = []
        for _ in range(1000):
            _ = arr[0]  # Carica in cache
            start = time.perf_counter()
            _ = arr[0]  # Cache hit
            hits.append(time.perf_counter() - start)
        
        # Misura cache miss
        misses = []
        for _ in range(1000):
            self.flush_cache_line(arr, 0)  # Flush
            start = time.perf_counter()
            _ = arr[0]  # Cache miss
            misses.append(time.perf_counter() - start)
        
        hit_avg = sum(hits) / len(hits)
        miss_avg = sum(misses) / len(misses)
        
        # Soglia = media tra hit e miss
        threshold = (hit_avg + miss_avg) / 2
        
        print(f"Cache hit:  {hit_avg*1e9:.1f} ns")
        print(f"Cache miss: {miss_avg*1e9:.1f} ns")
        print(f"Threshold:  {threshold*1e9:.1f} ns\n")
        
        return threshold
    
    def flush_cache_line(self, arr, index):
        """Flush cache line (x86 CLFLUSH)"""
        # In Python puro non possiamo eseguire CLFLUSH
        # In C: __builtin___clear_cache() o asm clflush
        pass
    
    def probe(self, arr, index):
        """Prova se indice √® in cache"""
        start = time.perf_counter()
        _ = arr[index]
        elapsed = time.perf_counter() - start
        
        return elapsed < self.threshold

def aes_cache_attack():
    """
    Attacco cache su AES T-table implementation
    AES usa lookup table ‚Üí indici leak tramite cache
    """
    
    # AES T-table (semplificata)
    T_table = list(range(256))
    
    def aes_round(plaintext, key):
        """AES round semplificato"""
        # Lookup dipende da (plaintext XOR key)
        index = plaintext ^ key
        return T_table[index]
    
    # ATTACCO
    print("AES Cache Timing Attack")
    print("="*50)
    
    real_key = 0x42
    attacker_controlled_plaintext = 0x00
    
    # 1. Flush tutta T-table
    print("1. Flush T-table dalla cache")
    
    # 2. Vittima esegue AES
    result = aes_round(attacker_controlled_plaintext, real_key)
    print(f"2. Vittima esegue AES(pt=0x{attacker_controlled_plaintext:02X}, key=?)")
    print(f"   ‚Üí T-table[{attacker_controlled_plaintext ^ real_key}] acceduta")
    
    # 3. Attacker prova tutti gli indici
    print("3. Attacker sonda cache...")
    cache_hits = []
    for guess_key in range(256):
        index = attacker_controlled_plaintext ^ guess_key
        # Se T_table[index] √® in cache ‚Üí guess_key potrebbe essere corretto
        # Simulazione: solo index corretto √® in cache
        if index == (attacker_controlled_plaintext ^ real_key):
            cache_hits.append(guess_key)
            print(f"   Cache HIT per key guess 0x{guess_key:02X}")
    
    if real_key in cache_hits:
        print(f"\n‚úì Chiave trovata: 0x{real_key:02X}")
    
aes_cache_attack()
```

### Spectre & Meltdown

Exploit speculazione CPU:

```python
def spectre_gadget(x):
    """
    Gadget Spectre vulnerabile
    Accede a memoria out-of-bounds durante esecuzione speculativa
    """
    
    array1_size = 16
    array1 = bytearray(array1_size)
    array2 = bytearray(256 * 4096)  # 256 pagine
    
    # Flush array1_size dalla cache
    # (CPU esegue speculativamente prima del check)
    
    if x < array1_size:  # Check bounds
        # Speculazione: CPU esegue prima che check sia risolto
        # x pu√≤ essere > array1_size
        secret_byte = array1[x]  # Out-of-bounds read!
        
        # Side-effect in cache
        _ = array2[secret_byte * 4096]  # Cache line dipende da byte segreto
    
    # Attacker probe array2 cache
    # Quale pagina √® in cache? ‚Üí Rivela secret_byte

def spectre_attack_demo():
    """Dimostra Spectre attack concettualmente"""
    
    print("Spectre Attack (Variant 1 - Bounds Check Bypass)")
    print("="*50)
    
    # Segreto in memoria (es. password)
    secret = b"SecretPassword123"
    secret_address = 1000  # Indirizzo memoria
    
    # Training branch predictor
    print("Training branch predictor...")
    for i in range(5, 10):
        spectre_gadget(i % 16)  # Tutti < 16 ‚Üí predictor impara "branch taken"
    
    # Attacco: x out-of-bounds
    malicious_x = secret_address  # Molto > 16
    print(f"Exploit: x = {malicious_x} (out-of-bounds)")
    
    # CPU esegue speculativamente:
    # 1. array1[1000] - legge secret (violazione)
    # 2. array2[secret * 4096] - side-effect cache
    # 3. Rollback (exception handler)
    # 4. MA cache state persiste!
    
    print("CPU specula ed esegue accesso illegale...")
    print("Rollback... ma cache √® stata modificata!")
    
    # Attacker prova cache
    print("\nProbing cache for secret byte...")
    # In realt√†: timing attack su array2[i*4096] per i in 0..255
    # Quale √® pi√π veloce? ‚Üí Quello in cache ‚Üí secret byte
    
    # Simulazione
    leaked_byte = ord('S')  # Primo carattere secret
    print(f"‚úì Byte leaked: 0x{leaked_byte:02X} ('{chr(leaked_byte)}')")

spectre_attack_demo()
```

### Contromisure Cache Attacks

```python
# 1. Constant-time implementations
def aes_constant_time_sbox(input_byte):
    """AES S-Box senza lookup table"""
    # Implementazione bitslice o masked
    # Tutti i path eseguiti sempre
    pass

# 2. Cache partitioning
# Intel CAT (Cache Allocation Technology)
# Isola cache tra processi

# 3. Disable CPU features
import subprocess

def disable_speculative_execution():
    """Disabilita speculazione (penalizzazione performance)"""
    # Linux kernel parameters
    subprocess.run([
        'sudo', 'sysctl',
        'kernel.unprivileged_bpf_disabled=1',
        'kernel.spectre_v2=on'
    ])

# 4. LFENCE instructions
# Barriera speculazione CPU
# asm volatile("lfence" ::: "memory");

# 5. Software mitigations
# - Retpoline (return trampolines)
# - KPTI (Kernel Page Table Isolation)
```

---

## 6. Fault Injection Attacks

### Glitching

Induceindicatore errori hardware per bypassare controlli.

### Voltage Glitching

```python
def voltage_glitch_attack():
    """
    Simula voltage glitching
    Abbassa voltaggio CPU per causare errori computazione
    """
    
    def check_pin_vulnerable(user_pin, correct_pin):
        """Funzione verificaPIN vulnerabile"""
        
        # Compara digit by digit
        for i in range(4):
            if user_pin[i] != correct_pin[i]:
                return False  # ‚Üê Glitch QUI: skip return
        return True  # Accesso garantito
    
    def check_pin_with_glitch(user_pin, correct_pin, glitch_timing):
        """Simulazione con glitch"""
        
        for i in range(4):
            if user_pin[i] != correct_pin[i]:
                
                # GLITCH: abbassa voltaggio ora
                if i == glitch_timing:
                    print(f"‚ö° GLITCH at digit {i}!")
                    # CPU salta istruzione return False
                    continue  # Simula skip
                
                return False
        return True
    
    # ATTACCO
    correct_pin = "1234"
    wrong_pin = "0000"
    
    print("Voltage Glitching Attack su PIN")
    print("="*50)
    print(f"Correct PIN: {correct_pin}")
    print(f"Attacker tries: {wrong_pin}")
    
    # Prova glitch a vari timing
    for glitch_time in range(4):
        result = check_pin_with_glitch(wrong_pin, correct_pin, glitch_time)
        if result:
            print(f"\n‚úì Bypass riuscito con glitch at digit {glitch_time}!")
            break

voltage_glitch_attack()
```

### Clock Glitching

```python
import time

def clock_glitch_attack():
    """
    Clock glitching: aumenta frequenza CPU oltre spec
    Causa errori computazione
    """
    
    def rsa_verify_signature(message, signature, public_key):
        """Verifica firma RSA (semplificata)"""
        
        # Calcolo: signature^e mod n
        # Con clock glitch: risultato errato
        expected = pow(signature, public_key[0], public_key[1])
        
        return expected == message
    
    # Parametri
    message = 12345
    real_signature = 98765
    public_key = (17, 3233)
    
    # Normale: firma INVALIDA
    valid = rsa_verify_signature(message, real_signature, public_key)
    print(f"Verifica normale: {valid}")
    
    # Con clock glitch: modular exponentiation errata
    print("\n‚ö° Applying clock glitch...")
    time.sleep(0.1)
    
    # Simula: glitch causa errore computazione
    # expected diventa uguale a message (errore!)
    glitched_result = True  # Bug!
    
    print(f"Verifica con glitch: {glitched_result}")
    print("‚úì Firma invalida accettata!")

clock_glitch_attack()
```

### Laser Fault Injection

```python
def laser_fault_injection():
    """
    Laser su chip causa bit-flip in memoria/registro
    Usato su smartcard, chip payment
    """
    
    def secure_boot_check(firmware_signature):
        """Secure boot: verifica firma firmware"""
        
        EXPECTED_SIGNATURE = 0xDEADBEEF
        
        if firmware_signature == EXPECTED_SIGNATURE:
            verified = True
        else:
            verified = False
        
        # if verified:  ‚Üê LASER punta QUI
        #     boot()
        
        return verified
    
    # ATTACCO
    print("Laser Fault Injection")
    print("="*50)
    
    malicious_firmware_sig = 0xBADBAD
    
    print(f"Firmware signature: 0x{malicious_firmware_sig:X}")
    result = secure_boot_check(malicious_firmware_sig)
    print(f"Verified: {result}")
    
    # Laser at precise moment
    print("\nüî¶ Laser shot at 'verified' variable...")
    print("Bit-flip: False ‚Üí True")
    
    # Simulazione: laser inverte bit
    result_glitched = not result  # False ‚Üí True
    print(f"Verified (after glitch): {result_glitched}")
    print("‚úì Secure boot bypassed!")

laser_fault_injection()
```

### Contromisure Fault Injection

```python
# 1. Redundant checks
def secure_pin_check(user_pin, correct_pin):
    """Check PIN con verifica ridondante"""
    
    result1 = (user_pin == correct_pin)
    result2 = (user_pin == correct_pin)  # Doppio check
    result3 = (user_pin == correct_pin)  # Triplo check!
    
    # Maggioranza voti
    votes = sum([result1, result2, result3])
    
    return votes >= 2

# 2. Sensors
def check_tamper_sensors():
    """Sensori anti-tamper"""
    voltage = read_voltage_sensor()
    clock_freq = read_clock_sensor()
    temperature = read_temp_sensor()
    light = read_light_sensor()  # Laser detection
    
    if voltage < 3.0 or voltage > 3.6:
        trigger_zeroize()  # Cancella chiavi
    
    if clock_freq > 48_000_000:  # > 48 MHz
        trigger_zeroize()
    
    if light > threshold:  # Laser detected
        trigger_zeroize()

# 3. Error detection codes
def ecc_protected_memory(data):
    """Memoria con ECC (Error Correction Code)"""
    # Hamming code, Reed-Solomon, etc.
    # Rileva e corregge bit-flip
    pass

# 4. Mesh sensors (smartcard)
# Rete metallica sopra chip
# Se rotta (decap attack) ‚Üí zeroize

# 5. Encapsulation
# Chip embedded in resina
# Difficile accesso fisico per laser/probe
```

---

## 7. Differential Fault Analysis (DFA)

### DFA su AES

```python
def dfa_aes_attack():
    """
    Differential Fault Analysis su AES
    Inietta fault nell'ultimo round per recuperare chiave
    """
    
    def aes_encrypt_last_round(plaintext, key):
        """Simula ultimo round AES"""
        # SubBytes ‚Üí ShiftRows ‚Üí AddRoundKey (no MixColumns)
        state = aes_sbox(plaintext ^ key)
        return state
    
    print("Differential Fault Analysis on AES")
    print("="*50)
    
    plaintext = 0x42
    secret_key = 0xAB
    
    # 1. Cifratura corretta
    correct_ciphertext = aes_encrypt_last_round(plaintext, secret_key)
    print(f"Correct ciphertext: 0x{correct_ciphertext:02X}")
    
    # 2. Cifratura con fault
    # Inietta fault nel byte 0 prima dell'ultimo round
    faulty_plaintext = plaintext ^ 0x01  # Flip 1 bit
    faulty_ciphertext = aes_encrypt_last_round(faulty_plaintext, secret_key)
    print(f"Faulty ciphertext:  0x{faulty_ciphertext:02X}")
    
    # 3. Differential
    diff_ciphertext = correct_ciphertext ^ faulty_ciphertext
    print(f"Ciphertext diff:    0x{diff_ciphertext:02X}")
    
    # 4. Key recovery
    # Prova tutte le chiavi possibili
    print("\nTrying all key candidates...")
    for key_guess in range(256):
        # Simula decifrazione parziale con guess
        state1 = aes_sbox(correct_ciphertext ^ key_guess)
        state2 = aes_sbox(faulty_ciphertext ^ key_guess)
        
        diff = state1 ^ state2
        
        # Confronta con differenziale atteso
        expected_diff = aes_sbox(plaintext) ^ aes_sbox(plaintext ^ 0x01)
        
        if diff == expected_diff:
            print(f"  Key candidate: 0x{key_guess:02X}")
            if key_guess == secret_key:
                print(f"  ‚úì CORRECT KEY FOUND!")

dfa_aes_attack()
```

---

## Best Practices Difesa

### Checklist Protezione Side-Channel

```markdown
‚úÖ **Implementazione**
- [ ] Usare algoritmi constant-time
- [ ] Evitare branch dipendenti da segreti
- [ ] Evitare lookup table con indici segreti
- [ ] Implementare masking crittografico

‚úÖ **Hardware**
- [ ] Sensori tamper (voltage, clock, temperature, light)
- [ ] Shielding elettromagnetico
- [ ] Isolamento acustico
- [ ] Random Number Generator hardware

‚úÖ **Software**
- [ ] Aggiornare microcode CPU (Spectre/Meltdown)
- [ ] Abilitare mitigazioni kernel (KPTI, retpoline)
- [ ] Usare librerie crypto certificate (OpenSSL, libsodium)
- [ ] Zeroize memoria sensibile dopo uso

‚úÖ **Fisico**
- [ ] Controllo accesso fisico dispositivi critici
- [ ] TEMPEST shielding per ambienti classified
- [ ] Distanza sicurezza da potenziali attaccanti
- [ ] Protezione chip (encapsulation, mesh)

‚úÖ **Monitoring**
- [ ] IDS per anomalie performance (cache timing)
- [ ] Log accessi memoria sensitiva
- [ ] Alerting su voltage/clock anomali
```

---

## Esercizi

### Esercizio 32.1 - Timing Attack (‚òÖ‚òÖ‚òÜ)

Implementa timing attack su confronto password:

```python
def vulnerable_password_check(user_pass, correct_pass):
    if len(user_pass) != len(correct_pass):
        return False
    for i in range(len(user_pass)):
        if user_pass[i] != correct_pass[i]:
            return False  # ‚Üê Esce immediatamente
    return True

# Task: Scrivi script che recupera password tramite timing
```

### Esercizio 32.2 - Power Analysis (‚òÖ‚òÖ‚òÖ)

Simula DPA su implementazione AES:
1. Genera 1000 tracce power con rumore
2. Implementa attacco correlazione
3. Recupera 1 byte chiave AES

### Esercizio 32.3 - Cache Timing (‚òÖ‚òÖ‚òÖ)

Implementa Flush+Reload su shared library:
1. Crea victim che accede array[secret_index]
2. Crea attacker che proba cache
3. Recupera secret_index

---

## Domande di Verifica

1. Qual √® la differenza tra SPA e DPA?
2. Perch√© constant-time implementations proteggono da timing attacks?
3. Come funziona attacco Spectre? Quale componente CPU sfrutta?
4. Quali contromisure hardware esistono contro fault injection?
5. Perch√© AES T-table implementation √® vulnerabile a cache timing?
6. Come pu√≤ un attaccante estrarre chiave RSA da emissioni acustiche?
7. Cosa significa "masking" come contromisura DPA?
8. Quali parametri fisici pu√≤ monitorare un tamper sensor?

---

## Riferimenti

### Paper Fondamentali
- **Timing Attacks on RSA** (Kocher, 1996)
- **Power Analysis Attacks** (Kocher et al., 1999)
- **Cache-Timing Attacks on AES** (Bernstein, 2005)
- **Acoustic Cryptanalysis** (Genkin et al., 2013)
- **Spectre & Meltdown** (2018)

### Tool
- **ChipWhisperer**: https://github.com/newaetech/chipwhisperer
- **Cachegrab**: https://github.com/cachegrab/cachegrab
- **Mastik**: https://github.com/0xADE1A1DE/Mastik

### Standard
- **FIPS 140-3**: Requisiti side-channel resistance
- **Common Criteria**: Valutazione sicurezza prodotti
- **TEMPEST**: Standard NSA emissioni EM

---

**Capitolo Precedente**: [31 - Tipologie di Malware](31_tipologie_di_malware.md)  
**Prossimo Capitolo**: [33 - Successivo](#)
