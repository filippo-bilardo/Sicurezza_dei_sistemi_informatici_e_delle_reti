# Capitolo 50 - Laboratorio: Sicurezza di Rete e Malware

> **Corso**: Sistemi e Reti 3  
> **Parte**: 12 - Laboratori Pratici  
> **Autore**: Prof. Filippo Bilardo

---

## Lab 1: Network Traffic Analysis

### Obiettivo

Analizzare traffico di rete per rilevare comunicazioni sospette.

### Setup con Scapy

```python
from scapy.all import *
from collections import defaultdict

def analyze_pcap(pcap_file):
    """Analizza file PCAP per pattern sospetti"""
    
    packets = rdpcap(pcap_file)
    
    # Statistiche
    stats = {
        'total': len(packets),
        'tcp': 0,
        'udp': 0,
        'http': 0,
        'https': 0,
        'dns': 0
    }
    
    connections = defaultdict(int)
    
    for pkt in packets:
        # Conta protocolli
        if TCP in pkt:
            stats['tcp'] += 1
            
            # Porta destinazione
            dport = pkt[TCP].dport
            if dport == 80:
                stats['http'] += 1
            elif dport == 443:
                stats['https'] += 1
            
            # Traccia connessioni
            if IP in pkt:
                conn = f"{pkt[IP].src}:{pkt[TCP].sport} -> {pkt[IP].dst}:{dport}"
                connections[conn] += 1
        
        elif UDP in pkt:
            stats['udp'] += 1
            if pkt[UDP].dport == 53:
                stats['dns'] += 1
    
    # Report
    print("=== STATISTICHE TRAFFICO ===")
    for key, value in stats.items():
        print(f"{key}: {value}")
    
    print("\n=== TOP 10 CONNESSIONI ===")
    for conn, count in sorted(connections.items(), key=lambda x: x[1], reverse=True)[:10]:
        print(f"{conn}: {count} pacchetti")

# Uso
# analyze_pcap("traffic.pcap")
```

### Rilevamento Porte Scan

```python
from scapy.all import *
from collections import defaultdict
import time

def detect_port_scan(pcap_file, threshold=20):
    """Rileva port scan (molte porte da stesso IP)"""
    
    packets = rdpcap(pcap_file)
    
    # IP ‚Üí Set di porte scansionate
    scans = defaultdict(set)
    
    for pkt in packets:
        if IP in pkt and TCP in pkt:
            src = pkt[IP].src
            dport = pkt[TCP].dport
            
            # SYN scan: SYN flag ma no ACK
            if pkt[TCP].flags == 'S':
                scans[src].add(dport)
    
    # Report IP sospetti
    print("=== POSSIBILI PORT SCAN ===")
    for ip, ports in scans.items():
        if len(ports) >= threshold:
            print(f"‚ö†Ô∏è  {ip}: {len(ports)} porte scansionate")
            print(f"   Porte: {sorted(list(ports))[:10]}...")

# detect_port_scan("traffic.pcap")
```

## Lab 2: DNS Tunneling Detection

### Scenario

Malware usa DNS per esfiltrazione dati.

### Rilevamento

```python
from scapy.all import *
import re

def detect_dns_tunneling(pcap_file):
    """Rileva DNS tunneling (query anomale)"""
    
    packets = rdpcap(pcap_file)
    
    suspicious = []
    
    for pkt in packets:
        if DNS in pkt and pkt.haslayer(DNSQR):
            query = pkt[DNSQR].qname.decode()
            
            # Pattern sospetti
            if len(query) > 50:  # Query molto lunga
                suspicious.append(('Lunghezza anomala', query))
            
            elif query.count('.') > 5:  # Troppi subdomain
                suspicious.append(('Troppi subdomain', query))
            
            # Base64/Hex encoding
            elif re.match(r'^[a-f0-9]{32,}\.', query):
                suspicious.append(('Possibile hex encoding', query))
    
    print("=== DNS TUNNELING DETECTION ===")
    for reason, query in suspicious:
        print(f"‚ö†Ô∏è  {reason}: {query[:60]}...")

# detect_dns_tunneling("dns_traffic.pcap")
```

## Lab 3: Simple IDS (Intrusion Detection System)

```python
from scapy.all import *
import re

class SimpleIDS:
    """IDS base con regole"""
    
    def __init__(self):
        self.rules = [
            {
                'name': 'SQL Injection',
                'pattern': rb'(union.*select|select.*from|insert.*into)',
                'protocol': 'http'
            },
            {
                'name': 'XSS Attempt',
                'pattern': rb'<script.*?>',
                'protocol': 'http'
            },
            {
                'name': 'SSH Brute Force',
                'threshold': 10,
                'port': 22,
                'protocol': 'tcp'
            }
        ]
        
        self.alerts = []
        self.ssh_attempts = defaultdict(int)
    
    def analyze_packet(self, pkt):
        """Analizza singolo pacchetto"""
        
        # HTTP payload
        if TCP in pkt and pkt[TCP].dport == 80:
            payload = bytes(pkt[TCP].payload)
            
            for rule in self.rules:
                if rule['protocol'] == 'http':
                    if re.search(rule['pattern'], payload, re.IGNORECASE):
                        self.alert(rule['name'], pkt)
        
        # SSH brute force
        if TCP in pkt and pkt[TCP].dport == 22:
            if IP in pkt:
                src = pkt[IP].src
                self.ssh_attempts[src] += 1
                
                if self.ssh_attempts[src] >= 10:
                    self.alert('SSH Brute Force', pkt)
                    self.ssh_attempts[src] = 0  # Reset
    
    def alert(self, rule_name, pkt):
        """Genera alert"""
        alert = {
            'rule': rule_name,
            'src': pkt[IP].src if IP in pkt else 'Unknown',
            'dst': pkt[IP].dst if IP in pkt else 'Unknown',
            'time': time.time()
        }
        
        self.alerts.append(alert)
        print(f"üö® ALERT: {rule_name} da {alert['src']} ‚Üí {alert['dst']}")
    
    def process_pcap(self, pcap_file):
        """Processa PCAP file"""
        packets = rdpcap(pcap_file)
        
        for pkt in packets:
            self.analyze_packet(pkt)
        
        print(f"\n=== TOTALE ALERT: {len(self.alerts)} ===")

# Uso
# ids = SimpleIDS()
# ids.process_pcap("traffic.pcap")
```

## Lab 4: Malware Hash Database

```python
import hashlib
import json

class MalwareDatabase:
    """Database hash malware noti"""
    
    def __init__(self, db_file='malware_hashes.json'):
        self.db_file = db_file
        self.load_database()
    
    def load_database(self):
        """Carica database hash"""
        try:
            with open(self.db_file, 'r') as f:
                self.hashes = json.load(f)
        except FileNotFoundError:
            self.hashes = {}
    
    def save_database(self):
        """Salva database"""
        with open(self.db_file, 'w') as f:
            json.dump(self.hashes, f, indent=2)
    
    def add_malware(self, file_path, malware_name, family=None):
        """Aggiungi hash malware"""
        with open(file_path, 'rb') as f:
            data = f.read()
        
        hash_md5 = hashlib.md5(data).hexdigest()
        hash_sha256 = hashlib.sha256(data).hexdigest()
        
        self.hashes[hash_sha256] = {
            'name': malware_name,
            'family': family,
            'md5': hash_md5,
            'size': len(data)
        }
        
        self.save_database()
        print(f"‚úÖ Aggiunto: {malware_name} (SHA-256: {hash_sha256})")
    
    def scan_file(self, file_path):
        """Scansiona file per match"""
        with open(file_path, 'rb') as f:
            data = f.read()
        
        hash_sha256 = hashlib.sha256(data).hexdigest()
        
        if hash_sha256 in self.hashes:
            info = self.hashes[hash_sha256]
            print(f"‚ö†Ô∏è  MALWARE DETECTED!")
            print(f"   Name: {info['name']}")
            print(f"   Family: {info.get('family', 'Unknown')}")
            print(f"   SHA-256: {hash_sha256}")
            return True
        else:
            print(f"‚úÖ File pulito (SHA-256: {hash_sha256})")
            return False

# Uso
db = MalwareDatabase()

# Simula aggiunta malware (in realt√† un file test)
# db.add_malware("suspicious.exe", "Trojan.GenericKD", "Trojan")

# Scansiona file
# db.scan_file("test_file.exe")
```

## Lab 5: Honeypot SSH

```python
import socket
import threading

class SSHHoneypot:
    """Honeypot SSH per catturare tentativi login"""
    
    def __init__(self, port=2222):
        self.port = port
        self.attempts = []
    
    def handle_client(self, client_socket, addr):
        """Gestisci connessione client"""
        try:
            # Banner SSH fake
            banner = b"SSH-2.0-OpenSSH_7.4\r\n"
            client_socket.send(banner)
            
            # Ricevi dati
            data = client_socket.recv(1024)
            
            # Log tentativo
            self.log_attempt(addr, data)
            
            # Chiudi
            client_socket.close()
            
        except Exception as e:
            print(f"Errore: {e}")
    
    def log_attempt(self, addr, data):
        """Logga tentativo"""
        attempt = {
            'ip': addr[0],
            'port': addr[1],
            'data': data[:100]  # Prime 100 byte
        }
        
        self.attempts.append(attempt)
        print(f"üïµÔ∏è  Tentativo da {addr[0]}:{addr[1]}")
        print(f"   Data: {data[:60]}")
    
    def start(self):
        """Avvia honeypot"""
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server.bind(('0.0.0.0', self.port))
        server.listen(5)
        
        print(f"üçØ SSH Honeypot in ascolto su porta {self.port}")
        
        try:
            while True:
                client, addr = server.accept()
                thread = threading.Thread(
                    target=self.handle_client,
                    args=(client, addr)
                )
                thread.start()
        
        except KeyboardInterrupt:
            print(f"\nüìä Totale tentativi: {len(self.attempts)}")
            server.close()

# Uso (richiede privilegi per porta < 1024)
# honeypot = SSHHoneypot(port=2222)
# honeypot.start()
```

## Lab 6: File Integrity Monitoring

```python
import hashlib
import json
import os
import time

class FileIntegrityMonitor:
    """Monitora modifiche a file critici"""
    
    def __init__(self, watch_dirs):
        self.watch_dirs = watch_dirs
        self.baseline = {}
        self.baseline_file = 'fim_baseline.json'
    
    def calculate_hash(self, filepath):
        """Calcola SHA-256 file"""
        sha256 = hashlib.sha256()
        
        with open(filepath, 'rb') as f:
            while chunk := f.read(8192):
                sha256.update(chunk)
        
        return sha256.hexdigest()
    
    def create_baseline(self):
        """Crea baseline hash"""
        print("üì∏ Creando baseline...")
        
        for watch_dir in self.watch_dirs:
            for root, dirs, files in os.walk(watch_dir):
                for file in files:
                    filepath = os.path.join(root, file)
                    
                    try:
                        file_hash = self.calculate_hash(filepath)
                        self.baseline[filepath] = file_hash
                    except:
                        pass
        
        # Salva baseline
        with open(self.baseline_file, 'w') as f:
            json.dump(self.baseline, f, indent=2)
        
        print(f"‚úÖ Baseline creata: {len(self.baseline)} file")
    
    def check_integrity(self):
        """Verifica integrit√†"""
        # Carica baseline
        with open(self.baseline_file, 'r') as f:
            self.baseline = json.load(f)
        
        changes = {
            'modified': [],
            'added': [],
            'deleted': []
        }
        
        current_files = set()
        
        # Controlla file esistenti
        for watch_dir in self.watch_dirs:
            for root, dirs, files in os.walk(watch_dir):
                for file in files:
                    filepath = os.path.join(root, file)
                    current_files.add(filepath)
                    
                    try:
                        current_hash = self.calculate_hash(filepath)
                        
                        if filepath in self.baseline:
                            # File esiste in baseline
                            if current_hash != self.baseline[filepath]:
                                changes['modified'].append(filepath)
                        else:
                            # File nuovo
                            changes['added'].append(filepath)
                    
                    except:
                        pass
        
        # Controlla file eliminati
        for filepath in self.baseline:
            if filepath not in current_files:
                changes['deleted'].append(filepath)
        
        # Report
        print("=== FILE INTEGRITY REPORT ===")
        
        if changes['modified']:
            print(f"\n‚ö†Ô∏è  MODIFICATI ({len(changes['modified'])}):")
            for f in changes['modified']:
                print(f"   {f}")
        
        if changes['added']:
            print(f"\n‚ûï AGGIUNTI ({len(changes['added'])}):")
            for f in changes['added'][:10]:  # Max 10
                print(f"   {f}")
        
        if changes['deleted']:
            print(f"\nÔøΩÔøΩÔ∏è  ELIMINATI ({len(changes['deleted'])}):")
            for f in changes['deleted']:
                print(f"   {f}")
        
        if not any(changes.values()):
            print("‚úÖ Nessuna modifica rilevata")

# Uso
# fim = FileIntegrityMonitor(['/etc', '/usr/bin'])
# fim.create_baseline()

# Dopo un po'...
# fim.check_integrity()
```

---

## üîó Collegamenti

- **Precedente**: [Capitolo 49](49_laboratorio_attacchi_e_difese.md)
- **Successivo**: [Capitolo 51 - Progetti Guidati](../PARTE_13_Progetti_Casi_Studio/51_progetti_guidati.md)
- **Indice**: [Torna all'indice](../00_INDICE.md)

**‚ö†Ô∏è Nota**: Tools per scopo educativo. In produzione usa soluzioni enterprise (Snort, Suricata, OSSEC).
